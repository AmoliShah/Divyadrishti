
DivyaDrishtiMaster.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002a18  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000068  20000000  00002a18  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000c0  20000068  00002a80  00010068  2**2
                  ALLOC
  3 .stack        00002000  20000128  00002b40  00010068  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010068  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010090  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001c893  00000000  00000000  000100eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000293c  00000000  00000000  0002c97e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00004013  00000000  00000000  0002f2ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000470  00000000  00000000  000332cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000460  00000000  00000000  0003373d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00019db5  00000000  00000000  00033b9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000a660  00000000  00000000  0004d952  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0008becf  00000000  00000000  00057fb2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001258  00000000  00000000  000e3e84  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20002128 	.word	0x20002128
       4:	00001411 	.word	0x00001411
       8:	0000140d 	.word	0x0000140d
       c:	0000140d 	.word	0x0000140d
	...
      2c:	0000140d 	.word	0x0000140d
	...
      38:	0000140d 	.word	0x0000140d
      3c:	0000140d 	.word	0x0000140d
      40:	0000140d 	.word	0x0000140d
      44:	0000140d 	.word	0x0000140d
      48:	0000140d 	.word	0x0000140d
      4c:	0000140d 	.word	0x0000140d
      50:	0000140d 	.word	0x0000140d
      54:	0000140d 	.word	0x0000140d
      58:	0000140d 	.word	0x0000140d
      5c:	0000140d 	.word	0x0000140d
      60:	0000140d 	.word	0x0000140d
      64:	00000d21 	.word	0x00000d21
      68:	00000d31 	.word	0x00000d31
      6c:	00000d41 	.word	0x00000d41
      70:	00000d51 	.word	0x00000d51
      74:	00000d61 	.word	0x00000d61
      78:	00000d71 	.word	0x00000d71
      7c:	0000140d 	.word	0x0000140d
      80:	0000140d 	.word	0x0000140d
      84:	0000140d 	.word	0x0000140d
      88:	0000140d 	.word	0x0000140d
      8c:	0000140d 	.word	0x0000140d
      90:	0000140d 	.word	0x0000140d
      94:	0000140d 	.word	0x0000140d
      98:	0000140d 	.word	0x0000140d
      9c:	0000140d 	.word	0x0000140d
      a0:	0000140d 	.word	0x0000140d
      a4:	0000140d 	.word	0x0000140d
      a8:	0000140d 	.word	0x0000140d
      ac:	0000140d 	.word	0x0000140d

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	20000068 	.word	0x20000068
      d0:	00000000 	.word	0x00000000
      d4:	00002a18 	.word	0x00002a18

000000d8 <frame_dummy>:
      d8:	b508      	push	{r3, lr}
      da:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4807      	ldr	r0, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4908      	ldr	r1, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d100      	bne.n	f2 <frame_dummy+0x1a>
      f0:	bd08      	pop	{r3, pc}
      f2:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f4:	2b00      	cmp	r3, #0
      f6:	d0fb      	beq.n	f0 <frame_dummy+0x18>
      f8:	4798      	blx	r3
      fa:	e7f9      	b.n	f0 <frame_dummy+0x18>
      fc:	00000000 	.word	0x00000000
     100:	00002a18 	.word	0x00002a18
     104:	2000006c 	.word	0x2000006c
     108:	00002a18 	.word	0x00002a18
     10c:	00000000 	.word	0x00000000

00000110 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
     110:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
     112:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     114:	2440      	movs	r4, #64	; 0x40
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
     116:	4281      	cmp	r1, r0
     118:	d30c      	bcc.n	134 <_sercom_get_sync_baud_val+0x24>
     11a:	2300      	movs	r3, #0
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
     11c:	1a09      	subs	r1, r1, r0
		baud_calculated++;
     11e:	3301      	adds	r3, #1
     120:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
     122:	4288      	cmp	r0, r1
     124:	d9fa      	bls.n	11c <_sercom_get_sync_baud_val+0xc>
		clock_value = clock_value - baudrate;
		baud_calculated++;
	}
	baud_calculated = baud_calculated - 1;
     126:	3b01      	subs	r3, #1
     128:	b29b      	uxth	r3, r3

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     12a:	2440      	movs	r4, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
     12c:	2bff      	cmp	r3, #255	; 0xff
     12e:	d801      	bhi.n	134 <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
     130:	8013      	strh	r3, [r2, #0]
		return STATUS_OK;
     132:	2400      	movs	r4, #0
	}
}
     134:	1c20      	adds	r0, r4, #0
     136:	bd10      	pop	{r4, pc}

00000138 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
     138:	b5f0      	push	{r4, r5, r6, r7, lr}
     13a:	465f      	mov	r7, fp
     13c:	4656      	mov	r6, sl
     13e:	464d      	mov	r5, r9
     140:	4644      	mov	r4, r8
     142:	b4f0      	push	{r4, r5, r6, r7}
     144:	b089      	sub	sp, #36	; 0x24
     146:	1c1c      	adds	r4, r3, #0
     148:	ab12      	add	r3, sp, #72	; 0x48
     14a:	781b      	ldrb	r3, [r3, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
     14c:	1c06      	adds	r6, r0, #0
     14e:	435e      	muls	r6, r3
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     150:	2540      	movs	r5, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
     152:	428e      	cmp	r6, r1
     154:	d900      	bls.n	158 <_sercom_get_async_baud_val+0x20>
     156:	e0c7      	b.n	2e8 <_sercom_get_async_baud_val+0x1b0>
     158:	1c25      	adds	r5, r4, #0
     15a:	9207      	str	r2, [sp, #28]
     15c:	1c0c      	adds	r4, r1, #0
     15e:	1c02      	adds	r2, r0, #0
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
     160:	2d00      	cmp	r5, #0
     162:	d151      	bne.n	208 <_sercom_get_async_baud_val+0xd0>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
     164:	1c18      	adds	r0, r3, #0
     166:	2100      	movs	r1, #0
     168:	2300      	movs	r3, #0
     16a:	4d63      	ldr	r5, [pc, #396]	; (2f8 <_sercom_get_async_baud_val+0x1c0>)
     16c:	47a8      	blx	r5
     16e:	4683      	mov	fp, r0
		ratio = long_division(temp1, peripheral_clock);
     170:	1c26      	adds	r6, r4, #0
     172:	2700      	movs	r7, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     174:	2300      	movs	r3, #0
     176:	2400      	movs	r4, #0
     178:	9302      	str	r3, [sp, #8]
     17a:	9403      	str	r4, [sp, #12]
     17c:	2200      	movs	r2, #0
     17e:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
     180:	203f      	movs	r0, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
     182:	2120      	movs	r1, #32
     184:	468c      	mov	ip, r1
     186:	391f      	subs	r1, #31
     188:	9600      	str	r6, [sp, #0]
     18a:	9701      	str	r7, [sp, #4]
     18c:	2420      	movs	r4, #32
     18e:	4264      	negs	r4, r4
     190:	1904      	adds	r4, r0, r4
     192:	d403      	bmi.n	19c <_sercom_get_async_baud_val+0x64>
     194:	1c0d      	adds	r5, r1, #0
     196:	40a5      	lsls	r5, r4
     198:	46a8      	mov	r8, r5
     19a:	e004      	b.n	1a6 <_sercom_get_async_baud_val+0x6e>
     19c:	4664      	mov	r4, ip
     19e:	1a24      	subs	r4, r4, r0
     1a0:	1c0d      	adds	r5, r1, #0
     1a2:	40e5      	lsrs	r5, r4
     1a4:	46a8      	mov	r8, r5
     1a6:	1c0c      	adds	r4, r1, #0
     1a8:	4084      	lsls	r4, r0
     1aa:	46a1      	mov	r9, r4

		r = r << 1;
     1ac:	1c14      	adds	r4, r2, #0
     1ae:	1c1d      	adds	r5, r3, #0
     1b0:	18a4      	adds	r4, r4, r2
     1b2:	415d      	adcs	r5, r3
     1b4:	1c22      	adds	r2, r4, #0
     1b6:	1c2b      	adds	r3, r5, #0

		if (n & bit_shift) {
     1b8:	465e      	mov	r6, fp
     1ba:	4647      	mov	r7, r8
     1bc:	423e      	tst	r6, r7
     1be:	d003      	beq.n	1c8 <_sercom_get_async_baud_val+0x90>
			r |= 0x01;
     1c0:	1c0e      	adds	r6, r1, #0
     1c2:	4326      	orrs	r6, r4
     1c4:	1c32      	adds	r2, r6, #0
     1c6:	1c2b      	adds	r3, r5, #0
		}

		if (r >= d) {
     1c8:	9c01      	ldr	r4, [sp, #4]
     1ca:	429c      	cmp	r4, r3
     1cc:	d810      	bhi.n	1f0 <_sercom_get_async_baud_val+0xb8>
     1ce:	d102      	bne.n	1d6 <_sercom_get_async_baud_val+0x9e>
     1d0:	9c00      	ldr	r4, [sp, #0]
     1d2:	4294      	cmp	r4, r2
     1d4:	d80c      	bhi.n	1f0 <_sercom_get_async_baud_val+0xb8>
			r = r - d;
     1d6:	9c00      	ldr	r4, [sp, #0]
     1d8:	9d01      	ldr	r5, [sp, #4]
     1da:	1b12      	subs	r2, r2, r4
     1dc:	41ab      	sbcs	r3, r5
			q |= bit_shift;
     1de:	464d      	mov	r5, r9
     1e0:	9e02      	ldr	r6, [sp, #8]
     1e2:	9f03      	ldr	r7, [sp, #12]
     1e4:	4335      	orrs	r5, r6
     1e6:	1c3c      	adds	r4, r7, #0
     1e8:	4646      	mov	r6, r8
     1ea:	4334      	orrs	r4, r6
     1ec:	9502      	str	r5, [sp, #8]
     1ee:	9403      	str	r4, [sp, #12]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     1f0:	3801      	subs	r0, #1
     1f2:	d2cb      	bcs.n	18c <_sercom_get_async_baud_val+0x54>

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
     1f4:	2200      	movs	r2, #0
     1f6:	2301      	movs	r3, #1
     1f8:	9802      	ldr	r0, [sp, #8]
     1fa:	9903      	ldr	r1, [sp, #12]
     1fc:	1a12      	subs	r2, r2, r0
     1fe:	418b      	sbcs	r3, r1
		baud_calculated = (65536 * scale) >> SHIFT;
     200:	0c11      	lsrs	r1, r2, #16
     202:	041b      	lsls	r3, r3, #16
     204:	4319      	orrs	r1, r3
     206:	e06c      	b.n	2e2 <_sercom_get_async_baud_val+0x1aa>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
     208:	2100      	movs	r1, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
     20a:	2d01      	cmp	r5, #1
     20c:	d169      	bne.n	2e2 <_sercom_get_async_baud_val+0x1aa>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
     20e:	0f61      	lsrs	r1, r4, #29
     210:	1c0f      	adds	r7, r1, #0
     212:	00e1      	lsls	r1, r4, #3
     214:	4688      	mov	r8, r1
			temp2 = ((uint64_t)baudrate * sample_num);
     216:	1c18      	adds	r0, r3, #0
     218:	2100      	movs	r1, #0
     21a:	2300      	movs	r3, #0
     21c:	4c36      	ldr	r4, [pc, #216]	; (2f8 <_sercom_get_async_baud_val+0x1c0>)
     21e:	47a0      	blx	r4
     220:	1c04      	adds	r4, r0, #0
     222:	1c0d      	adds	r5, r1, #0
     224:	2300      	movs	r3, #0
     226:	469c      	mov	ip, r3
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     228:	3320      	adds	r3, #32
     22a:	469b      	mov	fp, r3
     22c:	2601      	movs	r6, #1
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
     22e:	4663      	mov	r3, ip
     230:	9305      	str	r3, [sp, #20]
     232:	46b9      	mov	r9, r7
     234:	466b      	mov	r3, sp
     236:	7d1b      	ldrb	r3, [r3, #20]
     238:	9306      	str	r3, [sp, #24]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     23a:	2300      	movs	r3, #0
     23c:	469c      	mov	ip, r3
     23e:	2000      	movs	r0, #0
     240:	2100      	movs	r1, #0
	for (i = 63; i >= 0; i--) {
     242:	223f      	movs	r2, #63	; 0x3f
     244:	9400      	str	r4, [sp, #0]
     246:	9501      	str	r5, [sp, #4]
		bit_shift = (uint64_t)1 << i;
     248:	2320      	movs	r3, #32
     24a:	425b      	negs	r3, r3
     24c:	18d3      	adds	r3, r2, r3
     24e:	d403      	bmi.n	258 <_sercom_get_async_baud_val+0x120>
     250:	1c34      	adds	r4, r6, #0
     252:	409c      	lsls	r4, r3
     254:	1c23      	adds	r3, r4, #0
     256:	e004      	b.n	262 <_sercom_get_async_baud_val+0x12a>
     258:	465b      	mov	r3, fp
     25a:	1a9b      	subs	r3, r3, r2
     25c:	1c34      	adds	r4, r6, #0
     25e:	40dc      	lsrs	r4, r3
     260:	1c23      	adds	r3, r4, #0
     262:	1c37      	adds	r7, r6, #0
     264:	4097      	lsls	r7, r2

		r = r << 1;
     266:	1c04      	adds	r4, r0, #0
     268:	1c0d      	adds	r5, r1, #0
     26a:	1824      	adds	r4, r4, r0
     26c:	414d      	adcs	r5, r1
     26e:	1c20      	adds	r0, r4, #0
     270:	1c29      	adds	r1, r5, #0
     272:	9002      	str	r0, [sp, #8]
     274:	9103      	str	r1, [sp, #12]

		if (n & bit_shift) {
     276:	4644      	mov	r4, r8
     278:	403c      	ands	r4, r7
     27a:	46a2      	mov	sl, r4
     27c:	464c      	mov	r4, r9
     27e:	4023      	ands	r3, r4
     280:	4654      	mov	r4, sl
     282:	4323      	orrs	r3, r4
     284:	d005      	beq.n	292 <_sercom_get_async_baud_val+0x15a>
			r |= 0x01;
     286:	9b02      	ldr	r3, [sp, #8]
     288:	9c03      	ldr	r4, [sp, #12]
     28a:	1c1d      	adds	r5, r3, #0
     28c:	4335      	orrs	r5, r6
     28e:	1c28      	adds	r0, r5, #0
     290:	1c21      	adds	r1, r4, #0
		}

		if (r >= d) {
     292:	9b01      	ldr	r3, [sp, #4]
     294:	428b      	cmp	r3, r1
     296:	d80a      	bhi.n	2ae <_sercom_get_async_baud_val+0x176>
     298:	d102      	bne.n	2a0 <_sercom_get_async_baud_val+0x168>
     29a:	9b00      	ldr	r3, [sp, #0]
     29c:	4283      	cmp	r3, r0
     29e:	d806      	bhi.n	2ae <_sercom_get_async_baud_val+0x176>
			r = r - d;
     2a0:	9b00      	ldr	r3, [sp, #0]
     2a2:	9c01      	ldr	r4, [sp, #4]
     2a4:	1ac0      	subs	r0, r0, r3
     2a6:	41a1      	sbcs	r1, r4
			q |= bit_shift;
     2a8:	4663      	mov	r3, ip
     2aa:	433b      	orrs	r3, r7
     2ac:	469c      	mov	ip, r3
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     2ae:	3a01      	subs	r2, #1
     2b0:	d2ca      	bcs.n	248 <_sercom_get_async_baud_val+0x110>
     2b2:	9c00      	ldr	r4, [sp, #0]
     2b4:	9d01      	ldr	r5, [sp, #4]
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
     2b6:	4662      	mov	r2, ip
     2b8:	9905      	ldr	r1, [sp, #20]
     2ba:	1a53      	subs	r3, r2, r1
			baud_int = baud_int / BAUD_FP_MAX;
     2bc:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
     2be:	4a0f      	ldr	r2, [pc, #60]	; (2fc <_sercom_get_async_baud_val+0x1c4>)
     2c0:	4293      	cmp	r3, r2
     2c2:	d908      	bls.n	2d6 <_sercom_get_async_baud_val+0x19e>
     2c4:	9a06      	ldr	r2, [sp, #24]
     2c6:	3201      	adds	r2, #1
     2c8:	b2d2      	uxtb	r2, r2
     2ca:	9206      	str	r2, [sp, #24]
     2cc:	1c0a      	adds	r2, r1, #0
     2ce:	3201      	adds	r2, #1
     2d0:	9205      	str	r2, [sp, #20]
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
     2d2:	2a08      	cmp	r2, #8
     2d4:	d1ae      	bne.n	234 <_sercom_get_async_baud_val+0xfc>
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     2d6:	2540      	movs	r5, #64	; 0x40
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
     2d8:	9a06      	ldr	r2, [sp, #24]
     2da:	2a08      	cmp	r2, #8
     2dc:	d004      	beq.n	2e8 <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
     2de:	0351      	lsls	r1, r2, #13
     2e0:	4319      	orrs	r1, r3
	}

	*baudval = baud_calculated;
     2e2:	9b07      	ldr	r3, [sp, #28]
     2e4:	8019      	strh	r1, [r3, #0]
	return STATUS_OK;
     2e6:	2500      	movs	r5, #0
}
     2e8:	1c28      	adds	r0, r5, #0
     2ea:	b009      	add	sp, #36	; 0x24
     2ec:	bc3c      	pop	{r2, r3, r4, r5}
     2ee:	4690      	mov	r8, r2
     2f0:	4699      	mov	r9, r3
     2f2:	46a2      	mov	sl, r4
     2f4:	46ab      	mov	fp, r5
     2f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     2f8:	00001845 	.word	0x00001845
     2fc:	00001fff 	.word	0x00001fff

00000300 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
     300:	b510      	push	{r4, lr}
     302:	b082      	sub	sp, #8
     304:	1c04      	adds	r4, r0, #0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
     306:	4b0e      	ldr	r3, [pc, #56]	; (340 <sercom_set_gclk_generator+0x40>)
     308:	781b      	ldrb	r3, [r3, #0]
     30a:	2b00      	cmp	r3, #0
     30c:	d001      	beq.n	312 <sercom_set_gclk_generator+0x12>
     30e:	2900      	cmp	r1, #0
     310:	d00d      	beq.n	32e <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
     312:	a901      	add	r1, sp, #4
     314:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
     316:	2013      	movs	r0, #19
     318:	4b0a      	ldr	r3, [pc, #40]	; (344 <sercom_set_gclk_generator+0x44>)
     31a:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
     31c:	2013      	movs	r0, #19
     31e:	4b0a      	ldr	r3, [pc, #40]	; (348 <sercom_set_gclk_generator+0x48>)
     320:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
     322:	4b07      	ldr	r3, [pc, #28]	; (340 <sercom_set_gclk_generator+0x40>)
     324:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
     326:	2201      	movs	r2, #1
     328:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
     32a:	2000      	movs	r0, #0
     32c:	e006      	b.n	33c <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
     32e:	4b04      	ldr	r3, [pc, #16]	; (340 <sercom_set_gclk_generator+0x40>)
     330:	785b      	ldrb	r3, [r3, #1]
     332:	4283      	cmp	r3, r0
     334:	d001      	beq.n	33a <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
     336:	201d      	movs	r0, #29
     338:	e000      	b.n	33c <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
     33a:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
     33c:	b002      	add	sp, #8
     33e:	bd10      	pop	{r4, pc}
     340:	20000084 	.word	0x20000084
     344:	000012b5 	.word	0x000012b5
     348:	00001229 	.word	0x00001229

0000034c <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
     34c:	4b44      	ldr	r3, [pc, #272]	; (460 <_sercom_get_default_pad+0x114>)
     34e:	4298      	cmp	r0, r3
     350:	d033      	beq.n	3ba <_sercom_get_default_pad+0x6e>
     352:	d806      	bhi.n	362 <_sercom_get_default_pad+0x16>
     354:	4b43      	ldr	r3, [pc, #268]	; (464 <_sercom_get_default_pad+0x118>)
     356:	4298      	cmp	r0, r3
     358:	d00d      	beq.n	376 <_sercom_get_default_pad+0x2a>
     35a:	4b43      	ldr	r3, [pc, #268]	; (468 <_sercom_get_default_pad+0x11c>)
     35c:	4298      	cmp	r0, r3
     35e:	d01b      	beq.n	398 <_sercom_get_default_pad+0x4c>
     360:	e06f      	b.n	442 <_sercom_get_default_pad+0xf6>
     362:	4b42      	ldr	r3, [pc, #264]	; (46c <_sercom_get_default_pad+0x120>)
     364:	4298      	cmp	r0, r3
     366:	d04a      	beq.n	3fe <_sercom_get_default_pad+0xb2>
     368:	4b41      	ldr	r3, [pc, #260]	; (470 <_sercom_get_default_pad+0x124>)
     36a:	4298      	cmp	r0, r3
     36c:	d058      	beq.n	420 <_sercom_get_default_pad+0xd4>
     36e:	4b41      	ldr	r3, [pc, #260]	; (474 <_sercom_get_default_pad+0x128>)
     370:	4298      	cmp	r0, r3
     372:	d166      	bne.n	442 <_sercom_get_default_pad+0xf6>
     374:	e032      	b.n	3dc <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     376:	2901      	cmp	r1, #1
     378:	d006      	beq.n	388 <_sercom_get_default_pad+0x3c>
     37a:	2900      	cmp	r1, #0
     37c:	d063      	beq.n	446 <_sercom_get_default_pad+0xfa>
     37e:	2902      	cmp	r1, #2
     380:	d006      	beq.n	390 <_sercom_get_default_pad+0x44>
     382:	2903      	cmp	r1, #3
     384:	d006      	beq.n	394 <_sercom_get_default_pad+0x48>
     386:	e001      	b.n	38c <_sercom_get_default_pad+0x40>
     388:	483b      	ldr	r0, [pc, #236]	; (478 <_sercom_get_default_pad+0x12c>)
     38a:	e067      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     38c:	2000      	movs	r0, #0
     38e:	e065      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     390:	483a      	ldr	r0, [pc, #232]	; (47c <_sercom_get_default_pad+0x130>)
     392:	e063      	b.n	45c <_sercom_get_default_pad+0x110>
     394:	483a      	ldr	r0, [pc, #232]	; (480 <_sercom_get_default_pad+0x134>)
     396:	e061      	b.n	45c <_sercom_get_default_pad+0x110>
     398:	2901      	cmp	r1, #1
     39a:	d006      	beq.n	3aa <_sercom_get_default_pad+0x5e>
     39c:	2900      	cmp	r1, #0
     39e:	d054      	beq.n	44a <_sercom_get_default_pad+0xfe>
     3a0:	2902      	cmp	r1, #2
     3a2:	d006      	beq.n	3b2 <_sercom_get_default_pad+0x66>
     3a4:	2903      	cmp	r1, #3
     3a6:	d006      	beq.n	3b6 <_sercom_get_default_pad+0x6a>
     3a8:	e001      	b.n	3ae <_sercom_get_default_pad+0x62>
     3aa:	4836      	ldr	r0, [pc, #216]	; (484 <_sercom_get_default_pad+0x138>)
     3ac:	e056      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     3ae:	2000      	movs	r0, #0
     3b0:	e054      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     3b2:	4835      	ldr	r0, [pc, #212]	; (488 <_sercom_get_default_pad+0x13c>)
     3b4:	e052      	b.n	45c <_sercom_get_default_pad+0x110>
     3b6:	4835      	ldr	r0, [pc, #212]	; (48c <_sercom_get_default_pad+0x140>)
     3b8:	e050      	b.n	45c <_sercom_get_default_pad+0x110>
     3ba:	2901      	cmp	r1, #1
     3bc:	d006      	beq.n	3cc <_sercom_get_default_pad+0x80>
     3be:	2900      	cmp	r1, #0
     3c0:	d045      	beq.n	44e <_sercom_get_default_pad+0x102>
     3c2:	2902      	cmp	r1, #2
     3c4:	d006      	beq.n	3d4 <_sercom_get_default_pad+0x88>
     3c6:	2903      	cmp	r1, #3
     3c8:	d006      	beq.n	3d8 <_sercom_get_default_pad+0x8c>
     3ca:	e001      	b.n	3d0 <_sercom_get_default_pad+0x84>
     3cc:	4830      	ldr	r0, [pc, #192]	; (490 <_sercom_get_default_pad+0x144>)
     3ce:	e045      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     3d0:	2000      	movs	r0, #0
     3d2:	e043      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     3d4:	482f      	ldr	r0, [pc, #188]	; (494 <_sercom_get_default_pad+0x148>)
     3d6:	e041      	b.n	45c <_sercom_get_default_pad+0x110>
     3d8:	482f      	ldr	r0, [pc, #188]	; (498 <_sercom_get_default_pad+0x14c>)
     3da:	e03f      	b.n	45c <_sercom_get_default_pad+0x110>
     3dc:	2901      	cmp	r1, #1
     3de:	d006      	beq.n	3ee <_sercom_get_default_pad+0xa2>
     3e0:	2900      	cmp	r1, #0
     3e2:	d036      	beq.n	452 <_sercom_get_default_pad+0x106>
     3e4:	2902      	cmp	r1, #2
     3e6:	d006      	beq.n	3f6 <_sercom_get_default_pad+0xaa>
     3e8:	2903      	cmp	r1, #3
     3ea:	d006      	beq.n	3fa <_sercom_get_default_pad+0xae>
     3ec:	e001      	b.n	3f2 <_sercom_get_default_pad+0xa6>
     3ee:	482b      	ldr	r0, [pc, #172]	; (49c <_sercom_get_default_pad+0x150>)
     3f0:	e034      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     3f2:	2000      	movs	r0, #0
     3f4:	e032      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     3f6:	482a      	ldr	r0, [pc, #168]	; (4a0 <_sercom_get_default_pad+0x154>)
     3f8:	e030      	b.n	45c <_sercom_get_default_pad+0x110>
     3fa:	482a      	ldr	r0, [pc, #168]	; (4a4 <_sercom_get_default_pad+0x158>)
     3fc:	e02e      	b.n	45c <_sercom_get_default_pad+0x110>
     3fe:	2901      	cmp	r1, #1
     400:	d006      	beq.n	410 <_sercom_get_default_pad+0xc4>
     402:	2900      	cmp	r1, #0
     404:	d027      	beq.n	456 <_sercom_get_default_pad+0x10a>
     406:	2902      	cmp	r1, #2
     408:	d006      	beq.n	418 <_sercom_get_default_pad+0xcc>
     40a:	2903      	cmp	r1, #3
     40c:	d006      	beq.n	41c <_sercom_get_default_pad+0xd0>
     40e:	e001      	b.n	414 <_sercom_get_default_pad+0xc8>
     410:	4825      	ldr	r0, [pc, #148]	; (4a8 <_sercom_get_default_pad+0x15c>)
     412:	e023      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     414:	2000      	movs	r0, #0
     416:	e021      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     418:	4824      	ldr	r0, [pc, #144]	; (4ac <_sercom_get_default_pad+0x160>)
     41a:	e01f      	b.n	45c <_sercom_get_default_pad+0x110>
     41c:	4824      	ldr	r0, [pc, #144]	; (4b0 <_sercom_get_default_pad+0x164>)
     41e:	e01d      	b.n	45c <_sercom_get_default_pad+0x110>
     420:	2901      	cmp	r1, #1
     422:	d006      	beq.n	432 <_sercom_get_default_pad+0xe6>
     424:	2900      	cmp	r1, #0
     426:	d018      	beq.n	45a <_sercom_get_default_pad+0x10e>
     428:	2902      	cmp	r1, #2
     42a:	d006      	beq.n	43a <_sercom_get_default_pad+0xee>
     42c:	2903      	cmp	r1, #3
     42e:	d006      	beq.n	43e <_sercom_get_default_pad+0xf2>
     430:	e001      	b.n	436 <_sercom_get_default_pad+0xea>
     432:	4820      	ldr	r0, [pc, #128]	; (4b4 <_sercom_get_default_pad+0x168>)
     434:	e012      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     436:	2000      	movs	r0, #0
     438:	e010      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     43a:	481f      	ldr	r0, [pc, #124]	; (4b8 <_sercom_get_default_pad+0x16c>)
     43c:	e00e      	b.n	45c <_sercom_get_default_pad+0x110>
     43e:	481f      	ldr	r0, [pc, #124]	; (4bc <_sercom_get_default_pad+0x170>)
     440:	e00c      	b.n	45c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     442:	2000      	movs	r0, #0
     444:	e00a      	b.n	45c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     446:	481e      	ldr	r0, [pc, #120]	; (4c0 <_sercom_get_default_pad+0x174>)
     448:	e008      	b.n	45c <_sercom_get_default_pad+0x110>
     44a:	2003      	movs	r0, #3
     44c:	e006      	b.n	45c <_sercom_get_default_pad+0x110>
     44e:	481d      	ldr	r0, [pc, #116]	; (4c4 <_sercom_get_default_pad+0x178>)
     450:	e004      	b.n	45c <_sercom_get_default_pad+0x110>
     452:	481d      	ldr	r0, [pc, #116]	; (4c8 <_sercom_get_default_pad+0x17c>)
     454:	e002      	b.n	45c <_sercom_get_default_pad+0x110>
     456:	481d      	ldr	r0, [pc, #116]	; (4cc <_sercom_get_default_pad+0x180>)
     458:	e000      	b.n	45c <_sercom_get_default_pad+0x110>
     45a:	481d      	ldr	r0, [pc, #116]	; (4d0 <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
     45c:	4770      	bx	lr
     45e:	46c0      	nop			; (mov r8, r8)
     460:	42001000 	.word	0x42001000
     464:	42000800 	.word	0x42000800
     468:	42000c00 	.word	0x42000c00
     46c:	42001800 	.word	0x42001800
     470:	42001c00 	.word	0x42001c00
     474:	42001400 	.word	0x42001400
     478:	00050003 	.word	0x00050003
     47c:	00060003 	.word	0x00060003
     480:	00070003 	.word	0x00070003
     484:	00010003 	.word	0x00010003
     488:	001e0003 	.word	0x001e0003
     48c:	001f0003 	.word	0x001f0003
     490:	00090003 	.word	0x00090003
     494:	000a0003 	.word	0x000a0003
     498:	000b0003 	.word	0x000b0003
     49c:	00110003 	.word	0x00110003
     4a0:	00120003 	.word	0x00120003
     4a4:	00130003 	.word	0x00130003
     4a8:	000d0003 	.word	0x000d0003
     4ac:	000e0003 	.word	0x000e0003
     4b0:	000f0003 	.word	0x000f0003
     4b4:	00170003 	.word	0x00170003
     4b8:	00180003 	.word	0x00180003
     4bc:	00190003 	.word	0x00190003
     4c0:	00040003 	.word	0x00040003
     4c4:	00080003 	.word	0x00080003
     4c8:	00100003 	.word	0x00100003
     4cc:	000c0003 	.word	0x000c0003
     4d0:	00160003 	.word	0x00160003

000004d4 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
     4d4:	b530      	push	{r4, r5, lr}
     4d6:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
     4d8:	4b0c      	ldr	r3, [pc, #48]	; (50c <_sercom_get_sercom_inst_index+0x38>)
     4da:	466a      	mov	r2, sp
     4dc:	cb32      	ldmia	r3!, {r1, r4, r5}
     4de:	c232      	stmia	r2!, {r1, r4, r5}
     4e0:	cb32      	ldmia	r3!, {r1, r4, r5}
     4e2:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     4e4:	9b00      	ldr	r3, [sp, #0]
     4e6:	4283      	cmp	r3, r0
     4e8:	d006      	beq.n	4f8 <_sercom_get_sercom_inst_index+0x24>
     4ea:	2301      	movs	r3, #1
     4ec:	009a      	lsls	r2, r3, #2
     4ee:	4669      	mov	r1, sp
     4f0:	5852      	ldr	r2, [r2, r1]
     4f2:	4282      	cmp	r2, r0
     4f4:	d103      	bne.n	4fe <_sercom_get_sercom_inst_index+0x2a>
     4f6:	e000      	b.n	4fa <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     4f8:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     4fa:	b2d8      	uxtb	r0, r3
     4fc:	e003      	b.n	506 <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     4fe:	3301      	adds	r3, #1
     500:	2b06      	cmp	r3, #6
     502:	d1f3      	bne.n	4ec <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
     504:	2000      	movs	r0, #0
}
     506:	b007      	add	sp, #28
     508:	bd30      	pop	{r4, r5, pc}
     50a:	46c0      	nop			; (mov r8, r8)
     50c:	000028dc 	.word	0x000028dc

00000510 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
     510:	b5f0      	push	{r4, r5, r6, r7, lr}
     512:	4647      	mov	r7, r8
     514:	b480      	push	{r7}
     516:	1c0c      	adds	r4, r1, #0
     518:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
     51a:	2800      	cmp	r0, #0
     51c:	d110      	bne.n	540 <_read+0x30>
		return -1;
	}

	for (; len > 0; --len) {
     51e:	2a00      	cmp	r2, #0
     520:	dd0a      	ble.n	538 <_read+0x28>
     522:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
     524:	4e09      	ldr	r6, [pc, #36]	; (54c <_read+0x3c>)
     526:	4d0a      	ldr	r5, [pc, #40]	; (550 <_read+0x40>)
     528:	6830      	ldr	r0, [r6, #0]
     52a:	1c21      	adds	r1, r4, #0
     52c:	682b      	ldr	r3, [r5, #0]
     52e:	4798      	blx	r3
		ptr++;
     530:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
     532:	42bc      	cmp	r4, r7
     534:	d1f8      	bne.n	528 <_read+0x18>
     536:	e001      	b.n	53c <_read+0x2c>
     538:	2300      	movs	r3, #0
     53a:	4698      	mov	r8, r3
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
     53c:	4640      	mov	r0, r8
     53e:	e001      	b.n	544 <_read+0x34>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
     540:	2001      	movs	r0, #1
     542:	4240      	negs	r0, r0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
     544:	bc04      	pop	{r2}
     546:	4690      	mov	r8, r2
     548:	bdf0      	pop	{r4, r5, r6, r7, pc}
     54a:	46c0      	nop			; (mov r8, r8)
     54c:	200000d4 	.word	0x200000d4
     550:	200000cc 	.word	0x200000cc

00000554 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
     554:	b5f0      	push	{r4, r5, r6, r7, lr}
     556:	4647      	mov	r7, r8
     558:	b480      	push	{r7}
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
     55a:	3801      	subs	r0, #1
     55c:	2802      	cmp	r0, #2
     55e:	d815      	bhi.n	58c <_write+0x38>
		return -1;
	}

	for (; len != 0; --len) {
     560:	2a00      	cmp	r2, #0
     562:	d010      	beq.n	586 <_write+0x32>
     564:	1c15      	adds	r5, r2, #0
     566:	1c0e      	adds	r6, r1, #0
     568:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
     56a:	4b0c      	ldr	r3, [pc, #48]	; (59c <_write+0x48>)
     56c:	4698      	mov	r8, r3
     56e:	4f0c      	ldr	r7, [pc, #48]	; (5a0 <_write+0x4c>)
     570:	4643      	mov	r3, r8
     572:	6818      	ldr	r0, [r3, #0]
     574:	5d31      	ldrb	r1, [r6, r4]
     576:	683b      	ldr	r3, [r7, #0]
     578:	4798      	blx	r3
     57a:	2800      	cmp	r0, #0
     57c:	db09      	blt.n	592 <_write+0x3e>
			return -1;
		}
		++nChars;
     57e:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
     580:	42a5      	cmp	r5, r4
     582:	d1f5      	bne.n	570 <_write+0x1c>
     584:	e000      	b.n	588 <_write+0x34>
     586:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
     588:	1c20      	adds	r0, r4, #0
     58a:	e004      	b.n	596 <_write+0x42>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
     58c:	2001      	movs	r0, #1
     58e:	4240      	negs	r0, r0
     590:	e001      	b.n	596 <_write+0x42>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
     592:	2001      	movs	r0, #1
     594:	4240      	negs	r0, r0
		}
		++nChars;
	}
	return nChars;
}
     596:	bc04      	pop	{r2}
     598:	4690      	mov	r8, r2
     59a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     59c:	200000d4 	.word	0x200000d4
     5a0:	200000d0 	.word	0x200000d0

000005a4 <calculate_baud_value>:
*/
uint16_t calculate_baud_value(
const uint32_t baudrate,
const uint32_t peripheral_clock,
uint8_t sample_num)
{
     5a4:	b5f0      	push	{r4, r5, r6, r7, lr}
     5a6:	465f      	mov	r7, fp
     5a8:	4656      	mov	r6, sl
     5aa:	464d      	mov	r5, r9
     5ac:	4644      	mov	r4, r8
     5ae:	b4f0      	push	{r4, r5, r6, r7}
     5b0:	b085      	sub	sp, #20
     5b2:	1c03      	adds	r3, r0, #0
     5b4:	1c0c      	adds	r4, r1, #0
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
	uint64_t temp1;
	/* Calculate the BAUD value */
	temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
     5b6:	1c10      	adds	r0, r2, #0
     5b8:	2100      	movs	r1, #0
     5ba:	1c1a      	adds	r2, r3, #0
     5bc:	2300      	movs	r3, #0
     5be:	4d26      	ldr	r5, [pc, #152]	; (658 <calculate_baud_value+0xb4>)
     5c0:	47a8      	blx	r5
     5c2:	4683      	mov	fp, r0
	ratio = long_division(temp1, peripheral_clock);
     5c4:	1c26      	adds	r6, r4, #0
     5c6:	2700      	movs	r7, #0
* internal Calculate 64 bit division, ref can be found in
*/
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     5c8:	2300      	movs	r3, #0
     5ca:	4699      	mov	r9, r3
     5cc:	9303      	str	r3, [sp, #12]
     5ce:	2200      	movs	r2, #0
     5d0:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
     5d2:	213f      	movs	r1, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
     5d4:	2020      	movs	r0, #32
     5d6:	4682      	mov	sl, r0
     5d8:	381f      	subs	r0, #31
     5da:	4684      	mov	ip, r0
     5dc:	9600      	str	r6, [sp, #0]
     5de:	9701      	str	r7, [sp, #4]
     5e0:	1c0c      	adds	r4, r1, #0
     5e2:	2120      	movs	r1, #32
     5e4:	4249      	negs	r1, r1
     5e6:	1865      	adds	r5, r4, r1
     5e8:	d403      	bmi.n	5f2 <calculate_baud_value+0x4e>
     5ea:	4661      	mov	r1, ip
     5ec:	40a9      	lsls	r1, r5
     5ee:	1c0d      	adds	r5, r1, #0
     5f0:	e004      	b.n	5fc <calculate_baud_value+0x58>
     5f2:	4651      	mov	r1, sl
     5f4:	1b0d      	subs	r5, r1, r4
     5f6:	4661      	mov	r1, ip
     5f8:	40e9      	lsrs	r1, r5
     5fa:	1c0d      	adds	r5, r1, #0
     5fc:	4661      	mov	r1, ip
     5fe:	40a1      	lsls	r1, r4
     600:	4688      	mov	r8, r1
		r = r << 1;
     602:	1c10      	adds	r0, r2, #0
     604:	1c19      	adds	r1, r3, #0
     606:	1880      	adds	r0, r0, r2
     608:	4159      	adcs	r1, r3
     60a:	1c02      	adds	r2, r0, #0
     60c:	1c0b      	adds	r3, r1, #0
		if (n & bit_shift) {
     60e:	465e      	mov	r6, fp
     610:	422e      	tst	r6, r5
     612:	d003      	beq.n	61c <calculate_baud_value+0x78>
			r |= 0x01;
     614:	4666      	mov	r6, ip
     616:	4306      	orrs	r6, r0
     618:	1c32      	adds	r2, r6, #0
     61a:	1c0b      	adds	r3, r1, #0
		}
		if (r >= d) {
     61c:	9901      	ldr	r1, [sp, #4]
     61e:	4299      	cmp	r1, r3
     620:	d80e      	bhi.n	640 <calculate_baud_value+0x9c>
     622:	d102      	bne.n	62a <calculate_baud_value+0x86>
     624:	9900      	ldr	r1, [sp, #0]
     626:	4291      	cmp	r1, r2
     628:	d80a      	bhi.n	640 <calculate_baud_value+0x9c>
			r = r - d;
     62a:	9800      	ldr	r0, [sp, #0]
     62c:	9901      	ldr	r1, [sp, #4]
     62e:	1a12      	subs	r2, r2, r0
     630:	418b      	sbcs	r3, r1
			q |= bit_shift;
     632:	4649      	mov	r1, r9
     634:	4640      	mov	r0, r8
     636:	4301      	orrs	r1, r0
     638:	9803      	ldr	r0, [sp, #12]
     63a:	4328      	orrs	r0, r5
     63c:	4689      	mov	r9, r1
     63e:	9003      	str	r0, [sp, #12]
*/
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     640:	3c01      	subs	r4, #1
     642:	d2ce      	bcs.n	5e2 <calculate_baud_value+0x3e>
	uint64_t baud_calculated = 0;
	uint64_t temp1;
	/* Calculate the BAUD value */
	temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
	ratio = long_division(temp1, peripheral_clock);
	scale = ((uint64_t)1 << SHIFT) - ratio;
     644:	464b      	mov	r3, r9
     646:	4258      	negs	r0, r3
	baud_calculated = (65536 * scale) >> SHIFT;
	return baud_calculated;
     648:	0c00      	lsrs	r0, r0, #16
}
     64a:	b005      	add	sp, #20
     64c:	bc3c      	pop	{r2, r3, r4, r5}
     64e:	4690      	mov	r8, r2
     650:	4699      	mov	r9, r3
     652:	46a2      	mov	sl, r4
     654:	46ab      	mov	fp, r5
     656:	bdf0      	pop	{r4, r5, r6, r7, pc}
     658:	00001845 	.word	0x00001845

0000065c <ext_usart_clock_init>:

/* External connector(SERCOM2) UART bus and generic clock initialization */
void ext_usart_clock_init(void)
{
     65c:	b500      	push	{lr}
     65e:	b083      	sub	sp, #12
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
     660:	4a07      	ldr	r2, [pc, #28]	; (680 <ext_usart_clock_init+0x24>)
     662:	6a11      	ldr	r1, [r2, #32]
     664:	2310      	movs	r3, #16
     666:	430b      	orrs	r3, r1
     668:	6213      	str	r3, [r2, #32]
	/* Turn on module in PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, PM_APBCMASK_SERCOM2);
	/* Turn on Generic clock for USART */
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	//Default is generator 0. Other wise need to configure like below
	gclk_chan_conf.source_generator = GCLK_GENERATOR_1;
     66a:	a901      	add	r1, sp, #4
     66c:	2301      	movs	r3, #1
     66e:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
     670:	2016      	movs	r0, #22
     672:	4b04      	ldr	r3, [pc, #16]	; (684 <ext_usart_clock_init+0x28>)
     674:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
     676:	2016      	movs	r0, #22
     678:	4b03      	ldr	r3, [pc, #12]	; (688 <ext_usart_clock_init+0x2c>)
     67a:	4798      	blx	r3
}
     67c:	b003      	add	sp, #12
     67e:	bd00      	pop	{pc}
     680:	40000400 	.word	0x40000400
     684:	000012b5 	.word	0x000012b5
     688:	00001229 	.word	0x00001229

0000068c <ext_usart_pin_init>:
/* External connector(SERCOM2) pin initialization */
void ext_usart_pin_init(void)
{
     68c:	b510      	push	{r4, lr}

/*Assigning pin to the alternate peripheral function*/
static inline void pin_set_peripheral_function(uint32_t pinmux)
{
	uint8_t port = (uint8_t)((pinmux >> 16)/32);
	PORT->Group[port].PINCFG[((pinmux >> 16) - (port*32))].bit.PMUXEN = 1;
     68e:	4b0e      	ldr	r3, [pc, #56]	; (6c8 <ext_usart_pin_init+0x3c>)
     690:	2048      	movs	r0, #72	; 0x48
     692:	5c1a      	ldrb	r2, [r3, r0]
     694:	2101      	movs	r1, #1
     696:	430a      	orrs	r2, r1
     698:	541a      	strb	r2, [r3, r0]
	PORT->Group[port].PMUX[((pinmux >> 16) - (port*32))/2].reg &= ~(0xF << (4 * ((pinmux >> 16) & 0x01u)));
     69a:	2234      	movs	r2, #52	; 0x34
     69c:	5c98      	ldrb	r0, [r3, r2]
     69e:	240f      	movs	r4, #15
     6a0:	43a0      	bics	r0, r4
     6a2:	5498      	strb	r0, [r3, r2]
	PORT->Group[port].PMUX[((pinmux >> 16) - (port*32))/2].reg |= (uint8_t)((pinmux & 0x0000FFFF) << (4 * ((pinmux >> 16) & 0x01u)));
     6a4:	5c9c      	ldrb	r4, [r3, r2]
     6a6:	2003      	movs	r0, #3
     6a8:	4320      	orrs	r0, r4
     6aa:	5498      	strb	r0, [r3, r2]

/*Assigning pin to the alternate peripheral function*/
static inline void pin_set_peripheral_function(uint32_t pinmux)
{
	uint8_t port = (uint8_t)((pinmux >> 16)/32);
	PORT->Group[port].PINCFG[((pinmux >> 16) - (port*32))].bit.PMUXEN = 1;
     6ac:	2049      	movs	r0, #73	; 0x49
     6ae:	5c1c      	ldrb	r4, [r3, r0]
     6b0:	4321      	orrs	r1, r4
     6b2:	5419      	strb	r1, [r3, r0]
	PORT->Group[port].PMUX[((pinmux >> 16) - (port*32))/2].reg &= ~(0xF << (4 * ((pinmux >> 16) & 0x01u)));
     6b4:	5c98      	ldrb	r0, [r3, r2]
     6b6:	210f      	movs	r1, #15
     6b8:	4001      	ands	r1, r0
     6ba:	5499      	strb	r1, [r3, r2]
	PORT->Group[port].PMUX[((pinmux >> 16) - (port*32))/2].reg |= (uint8_t)((pinmux & 0x0000FFFF) << (4 * ((pinmux >> 16) & 0x01u)));
     6bc:	5c98      	ldrb	r0, [r3, r2]
     6be:	2130      	movs	r1, #48	; 0x30
     6c0:	4301      	orrs	r1, r0
     6c2:	5499      	strb	r1, [r3, r2]
void ext_usart_pin_init(void)
{
	/* PA08 and PA09 set into peripheral function*/
	pin_set_peripheral_function(PINMUX_PA08D_SERCOM2_PAD0);
	pin_set_peripheral_function(PINMUX_PA09D_SERCOM2_PAD1);
}
     6c4:	bd10      	pop	{r4, pc}
     6c6:	46c0      	nop			; (mov r8, r8)
     6c8:	41004400 	.word	0x41004400

000006cc <ext_usart_init>:
/* External connector(SERCOM2) UART initialization */
void ext_usart_init(void)
{
     6cc:	b508      	push	{r3, lr}
	uint16_t baud_value;
	baud_value = calculate_baud_value(USART_BAUD_RATE,system_gclk_chan_get_hz(SERCOM2_GCLK_ID_CORE),USART_SAMPLE_NUM);
     6ce:	2016      	movs	r0, #22
     6d0:	4b0f      	ldr	r3, [pc, #60]	; (710 <ext_usart_init+0x44>)
     6d2:	4798      	blx	r3
     6d4:	1c01      	adds	r1, r0, #0
     6d6:	2096      	movs	r0, #150	; 0x96
     6d8:	0180      	lsls	r0, r0, #6
     6da:	2210      	movs	r2, #16
     6dc:	4b0d      	ldr	r3, [pc, #52]	; (714 <ext_usart_init+0x48>)
     6de:	4798      	blx	r3
	1 corresponding SERCOM PAD[1] will be used for data reception RXD, PAD[0] will be used as TxD
	pin by setting TXPO bit as 0, 16x over-sampling is selected by setting the SAMPR bit as 0,
	Generic clock is enabled in all sleep modes by setting RUNSTDBY bit as 1,
	USART clock mode is selected as USART with internal clock by setting MODE bit into 1.
	*/
	SERCOM2->USART.CTRLA.reg = SERCOM_USART_CTRLA_DORD |
     6e0:	4b0d      	ldr	r3, [pc, #52]	; (718 <ext_usart_init+0x4c>)
     6e2:	4a0e      	ldr	r2, [pc, #56]	; (71c <ext_usart_init+0x50>)
     6e4:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_TXPO(0x0) |
	SERCOM_USART_CTRLA_SAMPR(0x0)|
	SERCOM_USART_CTRLA_RUNSTDBY |
	SERCOM_USART_CTRLA_MODE_USART_INT_CLK ;
	/* baud register value corresponds to the device communication baud rate */
	SERCOM2->USART.BAUD.reg = baud_value;
     6e6:	8198      	strh	r0, [r3, #12]
	/* 8-bits size is selected as character size by setting the bit CHSIZE as 0,
	TXEN bit and RXEN bits are set to enable the Transmitter and receiver*/
	SERCOM2->USART.CTRLB.reg = SERCOM_USART_CTRLB_CHSIZE(0x0) |
     6e8:	22c0      	movs	r2, #192	; 0xc0
     6ea:	0292      	lsls	r2, r2, #10
     6ec:	605a      	str	r2, [r3, #4]
	SERCOM_USART_CTRLB_TXEN |
	SERCOM_USART_CTRLB_RXEN ;
	/* synchronization busy */
	while(SERCOM2->USART.SYNCBUSY.bit.CTRLB);
     6ee:	1c19      	adds	r1, r3, #0
     6f0:	2201      	movs	r2, #1
     6f2:	69cb      	ldr	r3, [r1, #28]
     6f4:	089b      	lsrs	r3, r3, #2
     6f6:	421a      	tst	r2, r3
     6f8:	d1fb      	bne.n	6f2 <ext_usart_init+0x26>
	/* SERCOM2 peripheral enabled */
	SERCOM2->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     6fa:	4a07      	ldr	r2, [pc, #28]	; (718 <ext_usart_init+0x4c>)
     6fc:	6811      	ldr	r1, [r2, #0]
     6fe:	2302      	movs	r3, #2
     700:	430b      	orrs	r3, r1
     702:	6013      	str	r3, [r2, #0]
	/* synchronization busy */
	while(SERCOM2->USART.SYNCBUSY.reg & SERCOM_USART_SYNCBUSY_ENABLE);
     704:	1c11      	adds	r1, r2, #0
     706:	2202      	movs	r2, #2
     708:	69cb      	ldr	r3, [r1, #28]
     70a:	421a      	tst	r2, r3
     70c:	d1fc      	bne.n	708 <ext_usart_init+0x3c>
}
     70e:	bd08      	pop	{r3, pc}
     710:	000012d1 	.word	0x000012d1
     714:	000005a5 	.word	0x000005a5
     718:	42001000 	.word	0x42001000
     71c:	40100084 	.word	0x40100084

00000720 <USART_Receive>:
}

unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while(!(SERCOM2->USART.INTFLAG.bit.RXC));
     720:	4904      	ldr	r1, [pc, #16]	; (734 <USART_Receive+0x14>)
     722:	2201      	movs	r2, #1
     724:	7e0b      	ldrb	r3, [r1, #24]
     726:	089b      	lsrs	r3, r3, #2
     728:	421a      	tst	r2, r3
     72a:	d0fb      	beq.n	724 <USART_Receive+0x4>
	/* Get and return received data from buffer */
	return 	SERCOM2->USART.DATA.reg ;
     72c:	4b01      	ldr	r3, [pc, #4]	; (734 <USART_Receive+0x14>)
     72e:	8d18      	ldrh	r0, [r3, #40]	; 0x28
     730:	b2c0      	uxtb	r0, r0
}
     732:	4770      	bx	lr
     734:	42001000 	.word	0x42001000

00000738 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
     738:	b5f0      	push	{r4, r5, r6, r7, lr}
     73a:	465f      	mov	r7, fp
     73c:	4656      	mov	r6, sl
     73e:	464d      	mov	r5, r9
     740:	4644      	mov	r4, r8
     742:	b4f0      	push	{r4, r5, r6, r7}
     744:	b091      	sub	sp, #68	; 0x44
     746:	1c05      	adds	r5, r0, #0
     748:	1c0c      	adds	r4, r1, #0
     74a:	1c16      	adds	r6, r2, #0
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
     74c:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     74e:	1c08      	adds	r0, r1, #0
     750:	4bb9      	ldr	r3, [pc, #740]	; (a38 <usart_init+0x300>)
     752:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
     754:	6822      	ldr	r2, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
     756:	2305      	movs	r3, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
     758:	07d2      	lsls	r2, r2, #31
     75a:	d500      	bpl.n	75e <usart_init+0x26>
     75c:	e163      	b.n	a26 <usart_init+0x2ee>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
     75e:	6822      	ldr	r2, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
     760:	3317      	adds	r3, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
     762:	0792      	lsls	r2, r2, #30
     764:	d500      	bpl.n	768 <usart_init+0x30>
     766:	e15e      	b.n	a26 <usart_init+0x2ee>
     768:	49b4      	ldr	r1, [pc, #720]	; (a3c <usart_init+0x304>)
     76a:	6a0a      	ldr	r2, [r1, #32]
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
     76c:	1c87      	adds	r7, r0, #2
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
     76e:	3b1b      	subs	r3, #27
     770:	40bb      	lsls	r3, r7
     772:	4313      	orrs	r3, r2
     774:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
     776:	a90f      	add	r1, sp, #60	; 0x3c
     778:	272d      	movs	r7, #45	; 0x2d
     77a:	5df3      	ldrb	r3, [r6, r7]
     77c:	700b      	strb	r3, [r1, #0]
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     77e:	3014      	adds	r0, #20

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
     780:	b2c3      	uxtb	r3, r0
     782:	9302      	str	r3, [sp, #8]
     784:	1c18      	adds	r0, r3, #0
     786:	4bae      	ldr	r3, [pc, #696]	; (a40 <usart_init+0x308>)
     788:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
     78a:	9802      	ldr	r0, [sp, #8]
     78c:	4bad      	ldr	r3, [pc, #692]	; (a44 <usart_init+0x30c>)
     78e:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
     790:	5df0      	ldrb	r0, [r6, r7]
     792:	2100      	movs	r1, #0
     794:	4bac      	ldr	r3, [pc, #688]	; (a48 <usart_init+0x310>)
     796:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
     798:	7af3      	ldrb	r3, [r6, #11]
     79a:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
     79c:	2324      	movs	r3, #36	; 0x24
     79e:	5cf3      	ldrb	r3, [r6, r3]
     7a0:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
     7a2:	2325      	movs	r3, #37	; 0x25
     7a4:	5cf3      	ldrb	r3, [r6, r3]
     7a6:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
     7a8:	7ef3      	ldrb	r3, [r6, #27]
     7aa:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
     7ac:	7f33      	ldrb	r3, [r6, #28]
     7ae:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     7b0:	682b      	ldr	r3, [r5, #0]
     7b2:	469a      	mov	sl, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     7b4:	1c18      	adds	r0, r3, #0
     7b6:	4ba0      	ldr	r3, [pc, #640]	; (a38 <usart_init+0x300>)
     7b8:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     7ba:	3014      	adds	r0, #20
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
     7bc:	2200      	movs	r2, #0
     7be:	230e      	movs	r3, #14
     7c0:	a906      	add	r1, sp, #24
     7c2:	468c      	mov	ip, r1
     7c4:	4463      	add	r3, ip
     7c6:	801a      	strh	r2, [r3, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
     7c8:	8a33      	ldrh	r3, [r6, #16]
     7ca:	4699      	mov	r9, r3
     7cc:	2380      	movs	r3, #128	; 0x80
     7ce:	01db      	lsls	r3, r3, #7
     7d0:	4599      	cmp	r9, r3
     7d2:	d019      	beq.n	808 <usart_init+0xd0>
     7d4:	d804      	bhi.n	7e0 <usart_init+0xa8>
     7d6:	2380      	movs	r3, #128	; 0x80
     7d8:	019b      	lsls	r3, r3, #6
     7da:	4599      	cmp	r9, r3
     7dc:	d00a      	beq.n	7f4 <usart_init+0xbc>
     7de:	e103      	b.n	9e8 <usart_init+0x2b0>
     7e0:	23c0      	movs	r3, #192	; 0xc0
     7e2:	01db      	lsls	r3, r3, #7
     7e4:	4599      	cmp	r9, r3
     7e6:	d00a      	beq.n	7fe <usart_init+0xc6>
     7e8:	2380      	movs	r3, #128	; 0x80
     7ea:	021b      	lsls	r3, r3, #8
     7ec:	4599      	cmp	r9, r3
     7ee:	d100      	bne.n	7f2 <usart_init+0xba>
     7f0:	e0ff      	b.n	9f2 <usart_init+0x2ba>
     7f2:	e0f9      	b.n	9e8 <usart_init+0x2b0>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
     7f4:	2310      	movs	r3, #16
     7f6:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
     7f8:	3b0f      	subs	r3, #15
     7fa:	9307      	str	r3, [sp, #28]
     7fc:	e0fd      	b.n	9fa <usart_init+0x2c2>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
     7fe:	2308      	movs	r3, #8
     800:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
     802:	3b07      	subs	r3, #7
     804:	9307      	str	r3, [sp, #28]
     806:	e0f8      	b.n	9fa <usart_init+0x2c2>
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
     808:	6833      	ldr	r3, [r6, #0]
     80a:	469b      	mov	fp, r3
		(uint32_t)config->mux_setting |
     80c:	68f3      	ldr	r3, [r6, #12]
     80e:	9302      	str	r3, [sp, #8]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
     810:	6973      	ldr	r3, [r6, #20]
     812:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
     814:	7e33      	ldrb	r3, [r6, #24]
     816:	9304      	str	r3, [sp, #16]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
     818:	2326      	movs	r3, #38	; 0x26
     81a:	5cf3      	ldrb	r3, [r6, r3]
     81c:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
     81e:	6872      	ldr	r2, [r6, #4]
     820:	9206      	str	r2, [sp, #24]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
     822:	2a00      	cmp	r2, #0
     824:	d015      	beq.n	852 <usart_init+0x11a>
     826:	2380      	movs	r3, #128	; 0x80
     828:	055b      	lsls	r3, r3, #21
     82a:	429a      	cmp	r2, r3
     82c:	d136      	bne.n	89c <usart_init+0x164>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
     82e:	2327      	movs	r3, #39	; 0x27
     830:	5cf3      	ldrb	r3, [r6, r3]
     832:	2b00      	cmp	r3, #0
     834:	d136      	bne.n	8a4 <usart_init+0x16c>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
     836:	6a33      	ldr	r3, [r6, #32]
     838:	4698      	mov	r8, r3
     83a:	b2c0      	uxtb	r0, r0
     83c:	4b83      	ldr	r3, [pc, #524]	; (a4c <usart_init+0x314>)
     83e:	4798      	blx	r3
     840:	1c01      	adds	r1, r0, #0
     842:	4640      	mov	r0, r8
     844:	220e      	movs	r2, #14
     846:	ab06      	add	r3, sp, #24
     848:	469c      	mov	ip, r3
     84a:	4462      	add	r2, ip
     84c:	4b80      	ldr	r3, [pc, #512]	; (a50 <usart_init+0x318>)
     84e:	4798      	blx	r3
     850:	e025      	b.n	89e <usart_init+0x166>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
     852:	2308      	movs	r3, #8
     854:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
     856:	2300      	movs	r3, #0
     858:	9307      	str	r3, [sp, #28]
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
     85a:	2327      	movs	r3, #39	; 0x27
     85c:	5cf3      	ldrb	r3, [r6, r3]
     85e:	2b00      	cmp	r3, #0
     860:	d00b      	beq.n	87a <usart_init+0x142>
				status_code =
     862:	4643      	mov	r3, r8
     864:	9300      	str	r3, [sp, #0]
     866:	6a30      	ldr	r0, [r6, #32]
     868:	6ab1      	ldr	r1, [r6, #40]	; 0x28
     86a:	220e      	movs	r2, #14
     86c:	ab06      	add	r3, sp, #24
     86e:	469c      	mov	ip, r3
     870:	4462      	add	r2, ip
     872:	9b07      	ldr	r3, [sp, #28]
     874:	4f77      	ldr	r7, [pc, #476]	; (a54 <usart_init+0x31c>)
     876:	47b8      	blx	r7
     878:	e011      	b.n	89e <usart_init+0x166>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
     87a:	6a33      	ldr	r3, [r6, #32]
     87c:	1c1f      	adds	r7, r3, #0
     87e:	b2c0      	uxtb	r0, r0
     880:	4b72      	ldr	r3, [pc, #456]	; (a4c <usart_init+0x314>)
     882:	4798      	blx	r3
     884:	1c01      	adds	r1, r0, #0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
     886:	4643      	mov	r3, r8
     888:	9300      	str	r3, [sp, #0]
     88a:	1c38      	adds	r0, r7, #0
     88c:	220e      	movs	r2, #14
     88e:	ab06      	add	r3, sp, #24
     890:	469c      	mov	ip, r3
     892:	4462      	add	r2, ip
     894:	9b07      	ldr	r3, [sp, #28]
     896:	4f6f      	ldr	r7, [pc, #444]	; (a54 <usart_init+0x31c>)
     898:	47b8      	blx	r7
     89a:	e000      	b.n	89e <usart_init+0x166>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
     89c:	2000      	movs	r0, #0
     89e:	1e03      	subs	r3, r0, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
     8a0:	d000      	beq.n	8a4 <usart_init+0x16c>
     8a2:	e0c0      	b.n	a26 <usart_init+0x2ee>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
     8a4:	7e73      	ldrb	r3, [r6, #25]
     8a6:	2b00      	cmp	r3, #0
     8a8:	d002      	beq.n	8b0 <usart_init+0x178>
		usart_hw->RXPL.reg = config->receive_pulse_length;
     8aa:	7eb3      	ldrb	r3, [r6, #26]
     8ac:	4652      	mov	r2, sl
     8ae:	7393      	strb	r3, [r2, #14]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
     8b0:	682a      	ldr	r2, [r5, #0]
     8b2:	9f06      	ldr	r7, [sp, #24]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     8b4:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     8b6:	2b00      	cmp	r3, #0
     8b8:	d1fc      	bne.n	8b4 <usart_init+0x17c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
     8ba:	330e      	adds	r3, #14
     8bc:	aa06      	add	r2, sp, #24
     8be:	4694      	mov	ip, r2
     8c0:	4463      	add	r3, ip
     8c2:	881b      	ldrh	r3, [r3, #0]
     8c4:	4652      	mov	r2, sl
     8c6:	8193      	strh	r3, [r2, #12]
     8c8:	9b02      	ldr	r3, [sp, #8]
     8ca:	465a      	mov	r2, fp
     8cc:	4313      	orrs	r3, r2
     8ce:	9a03      	ldr	r2, [sp, #12]
     8d0:	4313      	orrs	r3, r2
     8d2:	433b      	orrs	r3, r7
     8d4:	464a      	mov	r2, r9
     8d6:	4313      	orrs	r3, r2
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
     8d8:	9a04      	ldr	r2, [sp, #16]
     8da:	0212      	lsls	r2, r2, #8
     8dc:	4313      	orrs	r3, r2
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
     8de:	9a05      	ldr	r2, [sp, #20]
     8e0:	0757      	lsls	r7, r2, #29

	/*Set baud val */
	usart_hw->BAUD.reg = baud;

	/* Set sample mode */
	ctrla |= transfer_mode;
     8e2:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
     8e4:	2327      	movs	r3, #39	; 0x27
     8e6:	5cf3      	ldrb	r3, [r6, r3]
     8e8:	2b00      	cmp	r3, #0
     8ea:	d101      	bne.n	8f0 <usart_init+0x1b8>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
     8ec:	3304      	adds	r3, #4
     8ee:	431f      	orrs	r7, r3
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
     8f0:	7f33      	ldrb	r3, [r6, #28]
     8f2:	0259      	lsls	r1, r3, #9
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
     8f4:	7e72      	ldrb	r2, [r6, #25]
     8f6:	0293      	lsls	r3, r2, #10
     8f8:	430b      	orrs	r3, r1
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
     8fa:	7f72      	ldrb	r2, [r6, #29]
     8fc:	0212      	lsls	r2, r2, #8
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
     8fe:	4313      	orrs	r3, r2
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
     900:	2224      	movs	r2, #36	; 0x24
     902:	5cb2      	ldrb	r2, [r6, r2]
     904:	0452      	lsls	r2, r2, #17
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
     906:	4313      	orrs	r3, r2
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
     908:	2225      	movs	r2, #37	; 0x25
     90a:	5cb2      	ldrb	r2, [r6, r2]
     90c:	0412      	lsls	r2, r2, #16
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
     90e:	4313      	orrs	r3, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
     910:	7af1      	ldrb	r1, [r6, #11]
     912:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
     914:	8933      	ldrh	r3, [r6, #8]
     916:	2bff      	cmp	r3, #255	; 0xff
     918:	d004      	beq.n	924 <usart_init+0x1ec>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
     91a:	2280      	movs	r2, #128	; 0x80
     91c:	0452      	lsls	r2, r2, #17
     91e:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
     920:	4319      	orrs	r1, r3
     922:	e005      	b.n	930 <usart_init+0x1f8>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
     924:	7ef3      	ldrb	r3, [r6, #27]
     926:	2b00      	cmp	r3, #0
     928:	d002      	beq.n	930 <usart_init+0x1f8>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
     92a:	2380      	movs	r3, #128	; 0x80
     92c:	04db      	lsls	r3, r3, #19
     92e:	431f      	orrs	r7, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     930:	232c      	movs	r3, #44	; 0x2c
     932:	5cf3      	ldrb	r3, [r6, r3]
     934:	2b00      	cmp	r3, #0
     936:	d103      	bne.n	940 <usart_init+0x208>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
     938:	4b47      	ldr	r3, [pc, #284]	; (a58 <usart_init+0x320>)
     93a:	789b      	ldrb	r3, [r3, #2]
     93c:	079b      	lsls	r3, r3, #30
     93e:	d501      	bpl.n	944 <usart_init+0x20c>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
     940:	2380      	movs	r3, #128	; 0x80
     942:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
     944:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     946:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     948:	2b00      	cmp	r3, #0
     94a:	d1fc      	bne.n	946 <usart_init+0x20e>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
     94c:	4653      	mov	r3, sl
     94e:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
     950:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     952:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     954:	2b00      	cmp	r3, #0
     956:	d1fc      	bne.n	952 <usart_init+0x21a>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
     958:	4653      	mov	r3, sl
     95a:	601f      	str	r7, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     95c:	ab0e      	add	r3, sp, #56	; 0x38
     95e:	2280      	movs	r2, #128	; 0x80
     960:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     962:	2200      	movs	r2, #0
     964:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
     966:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
     968:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
     96a:	6b33      	ldr	r3, [r6, #48]	; 0x30
     96c:	930a      	str	r3, [sp, #40]	; 0x28
     96e:	6b73      	ldr	r3, [r6, #52]	; 0x34
     970:	930b      	str	r3, [sp, #44]	; 0x2c
     972:	6bb3      	ldr	r3, [r6, #56]	; 0x38
     974:	930c      	str	r3, [sp, #48]	; 0x30
     976:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
     978:	9302      	str	r3, [sp, #8]
     97a:	930d      	str	r3, [sp, #52]	; 0x34
     97c:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
     97e:	ae0e      	add	r6, sp, #56	; 0x38
     980:	b2f9      	uxtb	r1, r7
     982:	00bb      	lsls	r3, r7, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
     984:	aa0a      	add	r2, sp, #40	; 0x28
     986:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
     988:	2800      	cmp	r0, #0
     98a:	d102      	bne.n	992 <usart_init+0x25a>
			current_pinmux = _sercom_get_default_pad(hw, pad);
     98c:	1c20      	adds	r0, r4, #0
     98e:	4b33      	ldr	r3, [pc, #204]	; (a5c <usart_init+0x324>)
     990:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
     992:	1c43      	adds	r3, r0, #1
     994:	d005      	beq.n	9a2 <usart_init+0x26a>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
     996:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
     998:	0c00      	lsrs	r0, r0, #16
     99a:	b2c0      	uxtb	r0, r0
     99c:	1c31      	adds	r1, r6, #0
     99e:	4b30      	ldr	r3, [pc, #192]	; (a60 <usart_init+0x328>)
     9a0:	4798      	blx	r3
     9a2:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
     9a4:	2f04      	cmp	r7, #4
     9a6:	d1eb      	bne.n	980 <usart_init+0x248>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
     9a8:	2300      	movs	r3, #0
     9aa:	60eb      	str	r3, [r5, #12]
     9ac:	612b      	str	r3, [r5, #16]
     9ae:	616b      	str	r3, [r5, #20]
     9b0:	61ab      	str	r3, [r5, #24]
     9b2:	61eb      	str	r3, [r5, #28]
     9b4:	622b      	str	r3, [r5, #32]
	}

	module->tx_buffer_ptr              = NULL;
     9b6:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
     9b8:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
     9ba:	2200      	movs	r2, #0
     9bc:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
     9be:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
     9c0:	3330      	adds	r3, #48	; 0x30
     9c2:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
     9c4:	3301      	adds	r3, #1
     9c6:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
     9c8:	3301      	adds	r3, #1
     9ca:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
     9cc:	3301      	adds	r3, #1
     9ce:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
     9d0:	6828      	ldr	r0, [r5, #0]
     9d2:	4b19      	ldr	r3, [pc, #100]	; (a38 <usart_init+0x300>)
     9d4:	4798      	blx	r3
     9d6:	1c04      	adds	r4, r0, #0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
     9d8:	4922      	ldr	r1, [pc, #136]	; (a64 <usart_init+0x32c>)
     9da:	4b23      	ldr	r3, [pc, #140]	; (a68 <usart_init+0x330>)
     9dc:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
     9de:	00a4      	lsls	r4, r4, #2
     9e0:	4b22      	ldr	r3, [pc, #136]	; (a6c <usart_init+0x334>)
     9e2:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
     9e4:	2300      	movs	r3, #0
     9e6:	e01e      	b.n	a26 <usart_init+0x2ee>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
     9e8:	2310      	movs	r3, #16
     9ea:	4698      	mov	r8, r3
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
     9ec:	2300      	movs	r3, #0
     9ee:	9307      	str	r3, [sp, #28]
     9f0:	e003      	b.n	9fa <usart_init+0x2c2>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
     9f2:	2303      	movs	r3, #3
     9f4:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
     9f6:	2300      	movs	r3, #0
     9f8:	9307      	str	r3, [sp, #28]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
     9fa:	6833      	ldr	r3, [r6, #0]
     9fc:	469b      	mov	fp, r3
		(uint32_t)config->mux_setting |
     9fe:	68f3      	ldr	r3, [r6, #12]
     a00:	9302      	str	r3, [sp, #8]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
     a02:	6973      	ldr	r3, [r6, #20]
     a04:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
     a06:	7e33      	ldrb	r3, [r6, #24]
     a08:	9304      	str	r3, [sp, #16]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
     a0a:	2326      	movs	r3, #38	; 0x26
     a0c:	5cf3      	ldrb	r3, [r6, r3]
     a0e:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
     a10:	6872      	ldr	r2, [r6, #4]
     a12:	9206      	str	r2, [sp, #24]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
     a14:	2a00      	cmp	r2, #0
     a16:	d100      	bne.n	a1a <usart_init+0x2e2>
     a18:	e71f      	b.n	85a <usart_init+0x122>
     a1a:	2380      	movs	r3, #128	; 0x80
     a1c:	055b      	lsls	r3, r3, #21
     a1e:	429a      	cmp	r2, r3
     a20:	d100      	bne.n	a24 <usart_init+0x2ec>
     a22:	e704      	b.n	82e <usart_init+0xf6>
     a24:	e73e      	b.n	8a4 <usart_init+0x16c>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
     a26:	1c18      	adds	r0, r3, #0
     a28:	b011      	add	sp, #68	; 0x44
     a2a:	bc3c      	pop	{r2, r3, r4, r5}
     a2c:	4690      	mov	r8, r2
     a2e:	4699      	mov	r9, r3
     a30:	46a2      	mov	sl, r4
     a32:	46ab      	mov	fp, r5
     a34:	bdf0      	pop	{r4, r5, r6, r7, pc}
     a36:	46c0      	nop			; (mov r8, r8)
     a38:	000004d5 	.word	0x000004d5
     a3c:	40000400 	.word	0x40000400
     a40:	000012b5 	.word	0x000012b5
     a44:	00001229 	.word	0x00001229
     a48:	00000301 	.word	0x00000301
     a4c:	000012d1 	.word	0x000012d1
     a50:	00000111 	.word	0x00000111
     a54:	00000139 	.word	0x00000139
     a58:	41002000 	.word	0x41002000
     a5c:	0000034d 	.word	0x0000034d
     a60:	000013ad 	.word	0x000013ad
     a64:	00000b15 	.word	0x00000b15
     a68:	00000cb9 	.word	0x00000cb9
     a6c:	200000d8 	.word	0x200000d8

00000a70 <usart_write_wait>:
 * \retval STATUS_ERR_DENIED If the transmitter is not enabled
 */
enum status_code usart_write_wait(
		struct usart_module *const module,
		const uint16_t tx_data)
{
     a70:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     a72:	6803      	ldr	r3, [r0, #0]

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
     a74:	79c4      	ldrb	r4, [r0, #7]
		return STATUS_ERR_DENIED;
     a76:	221c      	movs	r2, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
     a78:	2c00      	cmp	r4, #0
     a7a:	d00d      	beq.n	a98 <usart_write_wait+0x28>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
     a7c:	8dc0      	ldrh	r0, [r0, #46]	; 0x2e
     a7e:	b280      	uxth	r0, r0
		return STATUS_BUSY;
     a80:	3a17      	subs	r2, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
     a82:	2800      	cmp	r0, #0
     a84:	d108      	bne.n	a98 <usart_write_wait+0x28>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     a86:	69da      	ldr	r2, [r3, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     a88:	2a00      	cmp	r2, #0
     a8a:	d1fc      	bne.n	a86 <usart_write_wait+0x16>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;
     a8c:	8519      	strh	r1, [r3, #40]	; 0x28

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
     a8e:	2102      	movs	r1, #2
     a90:	7e1a      	ldrb	r2, [r3, #24]
     a92:	420a      	tst	r2, r1
     a94:	d0fc      	beq.n	a90 <usart_write_wait+0x20>
		/* Wait until data is sent */
	}

	return STATUS_OK;
     a96:	2200      	movs	r2, #0
}
     a98:	1c10      	adds	r0, r2, #0
     a9a:	bd10      	pop	{r4, pc}

00000a9c <usart_read_wait>:
 * \retval STATUS_ERR_DENIED        If the receiver is not enabled
 */
enum status_code usart_read_wait(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
     a9c:	b510      	push	{r4, lr}

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     a9e:	6804      	ldr	r4, [r0, #0]

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
     aa0:	7982      	ldrb	r2, [r0, #6]
		return STATUS_ERR_DENIED;
     aa2:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
     aa4:	2a00      	cmp	r2, #0
     aa6:	d033      	beq.n	b10 <usart_read_wait+0x74>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
     aa8:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
     aaa:	b292      	uxth	r2, r2
		return STATUS_BUSY;
     aac:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
     aae:	2a00      	cmp	r2, #0
     ab0:	d12e      	bne.n	b10 <usart_read_wait+0x74>
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
     ab2:	7e22      	ldrb	r2, [r4, #24]
     ab4:	0752      	lsls	r2, r2, #29
     ab6:	d52b      	bpl.n	b10 <usart_read_wait+0x74>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     ab8:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     aba:	2b00      	cmp	r3, #0
     abc:	d1fc      	bne.n	ab8 <usart_read_wait+0x1c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
     abe:	8b63      	ldrh	r3, [r4, #26]
     ac0:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
     ac2:	069a      	lsls	r2, r3, #26
     ac4:	d021      	beq.n	b0a <usart_read_wait+0x6e>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
     ac6:	079a      	lsls	r2, r3, #30
     ac8:	d503      	bpl.n	ad2 <usart_read_wait+0x36>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
     aca:	2302      	movs	r3, #2
     acc:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_BAD_FORMAT;
     ace:	3318      	adds	r3, #24
     ad0:	e01e      	b.n	b10 <usart_read_wait+0x74>
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
     ad2:	075a      	lsls	r2, r3, #29
     ad4:	d503      	bpl.n	ade <usart_read_wait+0x42>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
     ad6:	2304      	movs	r3, #4
     ad8:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_OVERFLOW;
     ada:	331a      	adds	r3, #26
     adc:	e018      	b.n	b10 <usart_read_wait+0x74>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
     ade:	07da      	lsls	r2, r3, #31
     ae0:	d503      	bpl.n	aea <usart_read_wait+0x4e>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
     ae2:	2301      	movs	r3, #1
     ae4:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_BAD_DATA;
     ae6:	3312      	adds	r3, #18
     ae8:	e012      	b.n	b10 <usart_read_wait+0x74>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
     aea:	06da      	lsls	r2, r3, #27
     aec:	d505      	bpl.n	afa <usart_read_wait+0x5e>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
     aee:	8b62      	ldrh	r2, [r4, #26]
     af0:	2310      	movs	r3, #16
     af2:	4313      	orrs	r3, r2
     af4:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_PROTOCOL;
     af6:	2342      	movs	r3, #66	; 0x42
     af8:	e00a      	b.n	b10 <usart_read_wait+0x74>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
     afa:	069b      	lsls	r3, r3, #26
     afc:	d505      	bpl.n	b0a <usart_read_wait+0x6e>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
     afe:	8b62      	ldrh	r2, [r4, #26]
     b00:	2320      	movs	r3, #32
     b02:	4313      	orrs	r3, r2
     b04:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_PACKET_COLLISION;
     b06:	2341      	movs	r3, #65	; 0x41
     b08:	e002      	b.n	b10 <usart_read_wait+0x74>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
     b0a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
     b0c:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
     b0e:	2300      	movs	r3, #0
}
     b10:	1c18      	adds	r0, r3, #0
     b12:	bd10      	pop	{r4, pc}

00000b14 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
     b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
     b16:	0080      	lsls	r0, r0, #2
     b18:	4b65      	ldr	r3, [pc, #404]	; (cb0 <_usart_interrupt_handler+0x19c>)
     b1a:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
     b1c:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     b1e:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     b20:	2b00      	cmp	r3, #0
     b22:	d1fc      	bne.n	b1e <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
     b24:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
     b26:	7da6      	ldrb	r6, [r4, #22]
     b28:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
			module->callback_enable_mask;
     b2a:	2331      	movs	r3, #49	; 0x31
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
	callback_status = module->callback_reg_mask &
     b2c:	5ceb      	ldrb	r3, [r5, r3]
     b2e:	2230      	movs	r2, #48	; 0x30
     b30:	5caf      	ldrb	r7, [r5, r2]
     b32:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
     b34:	07f3      	lsls	r3, r6, #31
     b36:	d522      	bpl.n	b7e <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
     b38:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
     b3a:	b29b      	uxth	r3, r3
     b3c:	2b00      	cmp	r3, #0
     b3e:	d01c      	beq.n	b7a <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
     b40:	6aaa      	ldr	r2, [r5, #40]	; 0x28
     b42:	7813      	ldrb	r3, [r2, #0]
     b44:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
     b46:	1c51      	adds	r1, r2, #1
     b48:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
     b4a:	7969      	ldrb	r1, [r5, #5]
     b4c:	2901      	cmp	r1, #1
     b4e:	d001      	beq.n	b54 <_usart_interrupt_handler+0x40>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
     b50:	b29b      	uxth	r3, r3
     b52:	e004      	b.n	b5e <_usart_interrupt_handler+0x4a>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
     b54:	7851      	ldrb	r1, [r2, #1]
     b56:	0209      	lsls	r1, r1, #8
     b58:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
     b5a:	3202      	adds	r2, #2
     b5c:	62aa      	str	r2, [r5, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
     b5e:	05db      	lsls	r3, r3, #23
     b60:	0ddb      	lsrs	r3, r3, #23
     b62:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
     b64:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
     b66:	3b01      	subs	r3, #1
     b68:	b29b      	uxth	r3, r3
     b6a:	85eb      	strh	r3, [r5, #46]	; 0x2e
     b6c:	2b00      	cmp	r3, #0
     b6e:	d106      	bne.n	b7e <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
     b70:	3301      	adds	r3, #1
     b72:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
     b74:	3301      	adds	r3, #1
     b76:	75a3      	strb	r3, [r4, #22]
     b78:	e001      	b.n	b7e <_usart_interrupt_handler+0x6a>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
     b7a:	2301      	movs	r3, #1
     b7c:	7523      	strb	r3, [r4, #20]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
     b7e:	07b3      	lsls	r3, r6, #30
     b80:	d509      	bpl.n	b96 <_usart_interrupt_handler+0x82>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
     b82:	2302      	movs	r3, #2
     b84:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
     b86:	2200      	movs	r2, #0
     b88:	3331      	adds	r3, #49	; 0x31
     b8a:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
     b8c:	07fb      	lsls	r3, r7, #31
     b8e:	d502      	bpl.n	b96 <_usart_interrupt_handler+0x82>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
     b90:	1c28      	adds	r0, r5, #0
     b92:	68eb      	ldr	r3, [r5, #12]
     b94:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
     b96:	0773      	lsls	r3, r6, #29
     b98:	d56a      	bpl.n	c70 <_usart_interrupt_handler+0x15c>

		if (module->remaining_rx_buffer_length) {
     b9a:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
     b9c:	b29b      	uxth	r3, r3
     b9e:	2b00      	cmp	r3, #0
     ba0:	d064      	beq.n	c6c <_usart_interrupt_handler+0x158>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
     ba2:	8b63      	ldrh	r3, [r4, #26]
     ba4:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
     ba6:	071a      	lsls	r2, r3, #28
     ba8:	d402      	bmi.n	bb0 <_usart_interrupt_handler+0x9c>

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
     baa:	223f      	movs	r2, #63	; 0x3f
     bac:	4013      	ands	r3, r2
     bae:	e001      	b.n	bb4 <_usart_interrupt_handler+0xa0>
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
     bb0:	2237      	movs	r2, #55	; 0x37
     bb2:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
     bb4:	2b00      	cmp	r3, #0
     bb6:	d037      	beq.n	c28 <_usart_interrupt_handler+0x114>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
     bb8:	079a      	lsls	r2, r3, #30
     bba:	d507      	bpl.n	bcc <_usart_interrupt_handler+0xb8>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
     bbc:	221a      	movs	r2, #26
     bbe:	2332      	movs	r3, #50	; 0x32
     bc0:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
     bc2:	8b62      	ldrh	r2, [r4, #26]
     bc4:	3b30      	subs	r3, #48	; 0x30
     bc6:	4313      	orrs	r3, r2
     bc8:	8363      	strh	r3, [r4, #26]
     bca:	e027      	b.n	c1c <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
     bcc:	075a      	lsls	r2, r3, #29
     bce:	d507      	bpl.n	be0 <_usart_interrupt_handler+0xcc>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
     bd0:	221e      	movs	r2, #30
     bd2:	2332      	movs	r3, #50	; 0x32
     bd4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
     bd6:	8b62      	ldrh	r2, [r4, #26]
     bd8:	3b2e      	subs	r3, #46	; 0x2e
     bda:	4313      	orrs	r3, r2
     bdc:	8363      	strh	r3, [r4, #26]
     bde:	e01d      	b.n	c1c <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
     be0:	07da      	lsls	r2, r3, #31
     be2:	d507      	bpl.n	bf4 <_usart_interrupt_handler+0xe0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
     be4:	2213      	movs	r2, #19
     be6:	2332      	movs	r3, #50	; 0x32
     be8:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
     bea:	8b62      	ldrh	r2, [r4, #26]
     bec:	3b31      	subs	r3, #49	; 0x31
     bee:	4313      	orrs	r3, r2
     bf0:	8363      	strh	r3, [r4, #26]
     bf2:	e013      	b.n	c1c <_usart_interrupt_handler+0x108>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
     bf4:	06da      	lsls	r2, r3, #27
     bf6:	d507      	bpl.n	c08 <_usart_interrupt_handler+0xf4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
     bf8:	2242      	movs	r2, #66	; 0x42
     bfa:	2332      	movs	r3, #50	; 0x32
     bfc:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
     bfe:	8b62      	ldrh	r2, [r4, #26]
     c00:	3b22      	subs	r3, #34	; 0x22
     c02:	4313      	orrs	r3, r2
     c04:	8363      	strh	r3, [r4, #26]
     c06:	e009      	b.n	c1c <_usart_interrupt_handler+0x108>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
     c08:	2220      	movs	r2, #32
     c0a:	421a      	tst	r2, r3
     c0c:	d006      	beq.n	c1c <_usart_interrupt_handler+0x108>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
     c0e:	3221      	adds	r2, #33	; 0x21
     c10:	2332      	movs	r3, #50	; 0x32
     c12:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
     c14:	8b62      	ldrh	r2, [r4, #26]
     c16:	3b12      	subs	r3, #18
     c18:	4313      	orrs	r3, r2
     c1a:	8363      	strh	r3, [r4, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
     c1c:	077b      	lsls	r3, r7, #29
     c1e:	d527      	bpl.n	c70 <_usart_interrupt_handler+0x15c>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
     c20:	1c28      	adds	r0, r5, #0
     c22:	696b      	ldr	r3, [r5, #20]
     c24:	4798      	blx	r3
     c26:	e023      	b.n	c70 <_usart_interrupt_handler+0x15c>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
     c28:	8d23      	ldrh	r3, [r4, #40]	; 0x28
     c2a:	05db      	lsls	r3, r3, #23
     c2c:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
     c2e:	b2da      	uxtb	r2, r3
     c30:	6a69      	ldr	r1, [r5, #36]	; 0x24
     c32:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
     c34:	6a6a      	ldr	r2, [r5, #36]	; 0x24
     c36:	1c51      	adds	r1, r2, #1
     c38:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
     c3a:	7969      	ldrb	r1, [r5, #5]
     c3c:	2901      	cmp	r1, #1
     c3e:	d104      	bne.n	c4a <_usart_interrupt_handler+0x136>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
     c40:	0a1b      	lsrs	r3, r3, #8
     c42:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
     c44:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     c46:	3301      	adds	r3, #1
     c48:	626b      	str	r3, [r5, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
     c4a:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
     c4c:	3b01      	subs	r3, #1
     c4e:	b29b      	uxth	r3, r3
     c50:	85ab      	strh	r3, [r5, #44]	; 0x2c
     c52:	2b00      	cmp	r3, #0
     c54:	d10c      	bne.n	c70 <_usart_interrupt_handler+0x15c>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
     c56:	3304      	adds	r3, #4
     c58:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
     c5a:	2200      	movs	r2, #0
     c5c:	332e      	adds	r3, #46	; 0x2e
     c5e:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
     c60:	07bb      	lsls	r3, r7, #30
     c62:	d505      	bpl.n	c70 <_usart_interrupt_handler+0x15c>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
     c64:	1c28      	adds	r0, r5, #0
     c66:	692b      	ldr	r3, [r5, #16]
     c68:	4798      	blx	r3
     c6a:	e001      	b.n	c70 <_usart_interrupt_handler+0x15c>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
     c6c:	2304      	movs	r3, #4
     c6e:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
     c70:	06f3      	lsls	r3, r6, #27
     c72:	d507      	bpl.n	c84 <_usart_interrupt_handler+0x170>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
     c74:	2310      	movs	r3, #16
     c76:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
     c78:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
     c7a:	06fb      	lsls	r3, r7, #27
     c7c:	d502      	bpl.n	c84 <_usart_interrupt_handler+0x170>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
     c7e:	1c28      	adds	r0, r5, #0
     c80:	69eb      	ldr	r3, [r5, #28]
     c82:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
     c84:	06b3      	lsls	r3, r6, #26
     c86:	d507      	bpl.n	c98 <_usart_interrupt_handler+0x184>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
     c88:	2320      	movs	r3, #32
     c8a:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
     c8c:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
     c8e:	073b      	lsls	r3, r7, #28
     c90:	d502      	bpl.n	c98 <_usart_interrupt_handler+0x184>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
     c92:	1c28      	adds	r0, r5, #0
     c94:	69ab      	ldr	r3, [r5, #24]
     c96:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
     c98:	0733      	lsls	r3, r6, #28
     c9a:	d507      	bpl.n	cac <_usart_interrupt_handler+0x198>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
     c9c:	2308      	movs	r3, #8
     c9e:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
     ca0:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
     ca2:	06bb      	lsls	r3, r7, #26
     ca4:	d502      	bpl.n	cac <_usart_interrupt_handler+0x198>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
     ca6:	6a2b      	ldr	r3, [r5, #32]
     ca8:	1c28      	adds	r0, r5, #0
     caa:	4798      	blx	r3
		}
	}
#endif
}
     cac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     cae:	46c0      	nop			; (mov r8, r8)
     cb0:	200000d8 	.word	0x200000d8

00000cb4 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
     cb4:	4770      	bx	lr
     cb6:	46c0      	nop			; (mov r8, r8)

00000cb8 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
     cb8:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
     cba:	4b0a      	ldr	r3, [pc, #40]	; (ce4 <_sercom_set_handler+0x2c>)
     cbc:	781b      	ldrb	r3, [r3, #0]
     cbe:	2b00      	cmp	r3, #0
     cc0:	d10c      	bne.n	cdc <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
     cc2:	4f09      	ldr	r7, [pc, #36]	; (ce8 <_sercom_set_handler+0x30>)
     cc4:	4e09      	ldr	r6, [pc, #36]	; (cec <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
     cc6:	4d0a      	ldr	r5, [pc, #40]	; (cf0 <_sercom_set_handler+0x38>)
     cc8:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
     cca:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
     ccc:	195a      	adds	r2, r3, r5
     cce:	6014      	str	r4, [r2, #0]
     cd0:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     cd2:	2b18      	cmp	r3, #24
     cd4:	d1f9      	bne.n	cca <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
     cd6:	2201      	movs	r2, #1
     cd8:	4b02      	ldr	r3, [pc, #8]	; (ce4 <_sercom_set_handler+0x2c>)
     cda:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
     cdc:	0080      	lsls	r0, r0, #2
     cde:	4b02      	ldr	r3, [pc, #8]	; (ce8 <_sercom_set_handler+0x30>)
     ce0:	50c1      	str	r1, [r0, r3]
}
     ce2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     ce4:	20000086 	.word	0x20000086
     ce8:	20000088 	.word	0x20000088
     cec:	00000cb5 	.word	0x00000cb5
     cf0:	200000d8 	.word	0x200000d8

00000cf4 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
     cf4:	b510      	push	{r4, lr}
     cf6:	b082      	sub	sp, #8
     cf8:	1c04      	adds	r4, r0, #0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
     cfa:	4668      	mov	r0, sp
     cfc:	4905      	ldr	r1, [pc, #20]	; (d14 <_sercom_get_interrupt_vector+0x20>)
     cfe:	2206      	movs	r2, #6
     d00:	4b05      	ldr	r3, [pc, #20]	; (d18 <_sercom_get_interrupt_vector+0x24>)
     d02:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
     d04:	1c20      	adds	r0, r4, #0
     d06:	4b05      	ldr	r3, [pc, #20]	; (d1c <_sercom_get_interrupt_vector+0x28>)
     d08:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
     d0a:	466b      	mov	r3, sp
     d0c:	5618      	ldrsb	r0, [r3, r0]
}
     d0e:	b002      	add	sp, #8
     d10:	bd10      	pop	{r4, pc}
     d12:	46c0      	nop			; (mov r8, r8)
     d14:	000028f4 	.word	0x000028f4
     d18:	000018e5 	.word	0x000018e5
     d1c:	000004d5 	.word	0x000004d5

00000d20 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
     d20:	b508      	push	{r3, lr}
     d22:	4b02      	ldr	r3, [pc, #8]	; (d2c <SERCOM0_Handler+0xc>)
     d24:	681b      	ldr	r3, [r3, #0]
     d26:	2000      	movs	r0, #0
     d28:	4798      	blx	r3
     d2a:	bd08      	pop	{r3, pc}
     d2c:	20000088 	.word	0x20000088

00000d30 <SERCOM1_Handler>:
     d30:	b508      	push	{r3, lr}
     d32:	4b02      	ldr	r3, [pc, #8]	; (d3c <SERCOM1_Handler+0xc>)
     d34:	685b      	ldr	r3, [r3, #4]
     d36:	2001      	movs	r0, #1
     d38:	4798      	blx	r3
     d3a:	bd08      	pop	{r3, pc}
     d3c:	20000088 	.word	0x20000088

00000d40 <SERCOM2_Handler>:
     d40:	b508      	push	{r3, lr}
     d42:	4b02      	ldr	r3, [pc, #8]	; (d4c <SERCOM2_Handler+0xc>)
     d44:	689b      	ldr	r3, [r3, #8]
     d46:	2002      	movs	r0, #2
     d48:	4798      	blx	r3
     d4a:	bd08      	pop	{r3, pc}
     d4c:	20000088 	.word	0x20000088

00000d50 <SERCOM3_Handler>:
     d50:	b508      	push	{r3, lr}
     d52:	4b02      	ldr	r3, [pc, #8]	; (d5c <SERCOM3_Handler+0xc>)
     d54:	68db      	ldr	r3, [r3, #12]
     d56:	2003      	movs	r0, #3
     d58:	4798      	blx	r3
     d5a:	bd08      	pop	{r3, pc}
     d5c:	20000088 	.word	0x20000088

00000d60 <SERCOM4_Handler>:
     d60:	b508      	push	{r3, lr}
     d62:	4b02      	ldr	r3, [pc, #8]	; (d6c <SERCOM4_Handler+0xc>)
     d64:	691b      	ldr	r3, [r3, #16]
     d66:	2004      	movs	r0, #4
     d68:	4798      	blx	r3
     d6a:	bd08      	pop	{r3, pc}
     d6c:	20000088 	.word	0x20000088

00000d70 <SERCOM5_Handler>:
     d70:	b508      	push	{r3, lr}
     d72:	4b02      	ldr	r3, [pc, #8]	; (d7c <SERCOM5_Handler+0xc>)
     d74:	695b      	ldr	r3, [r3, #20]
     d76:	2005      	movs	r0, #5
     d78:	4798      	blx	r3
     d7a:	bd08      	pop	{r3, pc}
     d7c:	20000088 	.word	0x20000088

00000d80 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
     d80:	4b0c      	ldr	r3, [pc, #48]	; (db4 <cpu_irq_enter_critical+0x34>)
     d82:	681b      	ldr	r3, [r3, #0]
     d84:	2b00      	cmp	r3, #0
     d86:	d110      	bne.n	daa <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     d88:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
     d8c:	2b00      	cmp	r3, #0
     d8e:	d109      	bne.n	da4 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     d90:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
     d92:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
     d96:	2200      	movs	r2, #0
     d98:	4b07      	ldr	r3, [pc, #28]	; (db8 <cpu_irq_enter_critical+0x38>)
     d9a:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
     d9c:	3201      	adds	r2, #1
     d9e:	4b07      	ldr	r3, [pc, #28]	; (dbc <cpu_irq_enter_critical+0x3c>)
     da0:	701a      	strb	r2, [r3, #0]
     da2:	e002      	b.n	daa <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
     da4:	2200      	movs	r2, #0
     da6:	4b05      	ldr	r3, [pc, #20]	; (dbc <cpu_irq_enter_critical+0x3c>)
     da8:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
     daa:	4a02      	ldr	r2, [pc, #8]	; (db4 <cpu_irq_enter_critical+0x34>)
     dac:	6813      	ldr	r3, [r2, #0]
     dae:	3301      	adds	r3, #1
     db0:	6013      	str	r3, [r2, #0]
}
     db2:	4770      	bx	lr
     db4:	200000a0 	.word	0x200000a0
     db8:	20000000 	.word	0x20000000
     dbc:	200000a4 	.word	0x200000a4

00000dc0 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
     dc0:	4b08      	ldr	r3, [pc, #32]	; (de4 <cpu_irq_leave_critical+0x24>)
     dc2:	681a      	ldr	r2, [r3, #0]
     dc4:	3a01      	subs	r2, #1
     dc6:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
     dc8:	681b      	ldr	r3, [r3, #0]
     dca:	2b00      	cmp	r3, #0
     dcc:	d109      	bne.n	de2 <cpu_irq_leave_critical+0x22>
     dce:	4b06      	ldr	r3, [pc, #24]	; (de8 <cpu_irq_leave_critical+0x28>)
     dd0:	781b      	ldrb	r3, [r3, #0]
     dd2:	2b00      	cmp	r3, #0
     dd4:	d005      	beq.n	de2 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
     dd6:	2201      	movs	r2, #1
     dd8:	4b04      	ldr	r3, [pc, #16]	; (dec <cpu_irq_leave_critical+0x2c>)
     dda:	701a      	strb	r2, [r3, #0]
     ddc:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     de0:	b662      	cpsie	i
	}
}
     de2:	4770      	bx	lr
     de4:	200000a0 	.word	0x200000a0
     de8:	200000a4 	.word	0x200000a4
     dec:	20000000 	.word	0x20000000

00000df0 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
     df0:	b5f0      	push	{r4, r5, r6, r7, lr}
     df2:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     df4:	ac01      	add	r4, sp, #4
     df6:	2501      	movs	r5, #1
     df8:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
     dfa:	2700      	movs	r7, #0
     dfc:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
     dfe:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
     e00:	203e      	movs	r0, #62	; 0x3e
     e02:	1c21      	adds	r1, r4, #0
     e04:	4e06      	ldr	r6, [pc, #24]	; (e20 <system_board_init+0x30>)
     e06:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     e08:	2280      	movs	r2, #128	; 0x80
     e0a:	05d2      	lsls	r2, r2, #23
     e0c:	4b05      	ldr	r3, [pc, #20]	; (e24 <system_board_init+0x34>)
     e0e:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
     e10:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
     e12:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
     e14:	200f      	movs	r0, #15
     e16:	1c21      	adds	r1, r4, #0
     e18:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
     e1a:	b003      	add	sp, #12
     e1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e1e:	46c0      	nop			; (mov r8, r8)
     e20:	00000e29 	.word	0x00000e29
     e24:	41004480 	.word	0x41004480

00000e28 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
     e28:	b500      	push	{lr}
     e2a:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     e2c:	ab01      	add	r3, sp, #4
     e2e:	2280      	movs	r2, #128	; 0x80
     e30:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
     e32:	780a      	ldrb	r2, [r1, #0]
     e34:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
     e36:	784a      	ldrb	r2, [r1, #1]
     e38:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
     e3a:	788a      	ldrb	r2, [r1, #2]
     e3c:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
     e3e:	1c19      	adds	r1, r3, #0
     e40:	4b01      	ldr	r3, [pc, #4]	; (e48 <port_pin_set_config+0x20>)
     e42:	4798      	blx	r3
}
     e44:	b003      	add	sp, #12
     e46:	bd00      	pop	{pc}
     e48:	000013ad 	.word	0x000013ad

00000e4c <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
     e4c:	b508      	push	{r3, lr}
	switch (clock_source) {
     e4e:	2808      	cmp	r0, #8
     e50:	d803      	bhi.n	e5a <system_clock_source_get_hz+0xe>
     e52:	0080      	lsls	r0, r0, #2
     e54:	4b1b      	ldr	r3, [pc, #108]	; (ec4 <system_clock_source_get_hz+0x78>)
     e56:	581b      	ldr	r3, [r3, r0]
     e58:	469f      	mov	pc, r3

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
     e5a:	2000      	movs	r0, #0
     e5c:	e031      	b.n	ec2 <system_clock_source_get_hz+0x76>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
     e5e:	4b1a      	ldr	r3, [pc, #104]	; (ec8 <system_clock_source_get_hz+0x7c>)
     e60:	6918      	ldr	r0, [r3, #16]
     e62:	e02e      	b.n	ec2 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
     e64:	4b19      	ldr	r3, [pc, #100]	; (ecc <system_clock_source_get_hz+0x80>)
     e66:	6a18      	ldr	r0, [r3, #32]
     e68:	0580      	lsls	r0, r0, #22
     e6a:	0f80      	lsrs	r0, r0, #30
     e6c:	4b18      	ldr	r3, [pc, #96]	; (ed0 <system_clock_source_get_hz+0x84>)
     e6e:	40c3      	lsrs	r3, r0
     e70:	1c18      	adds	r0, r3, #0
     e72:	e026      	b.n	ec2 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
     e74:	4b14      	ldr	r3, [pc, #80]	; (ec8 <system_clock_source_get_hz+0x7c>)
     e76:	6958      	ldr	r0, [r3, #20]
     e78:	e023      	b.n	ec2 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
     e7a:	4b13      	ldr	r3, [pc, #76]	; (ec8 <system_clock_source_get_hz+0x7c>)
     e7c:	681b      	ldr	r3, [r3, #0]
     e7e:	2002      	movs	r0, #2
     e80:	4018      	ands	r0, r3
     e82:	d01e      	beq.n	ec2 <system_clock_source_get_hz+0x76>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
     e84:	4911      	ldr	r1, [pc, #68]	; (ecc <system_clock_source_get_hz+0x80>)
     e86:	2210      	movs	r2, #16
     e88:	68cb      	ldr	r3, [r1, #12]
     e8a:	421a      	tst	r2, r3
     e8c:	d0fc      	beq.n	e88 <system_clock_source_get_hz+0x3c>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
     e8e:	4b0e      	ldr	r3, [pc, #56]	; (ec8 <system_clock_source_get_hz+0x7c>)
     e90:	681b      	ldr	r3, [r3, #0]
     e92:	075b      	lsls	r3, r3, #29
     e94:	d514      	bpl.n	ec0 <system_clock_source_get_hz+0x74>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
     e96:	2000      	movs	r0, #0
     e98:	4b0e      	ldr	r3, [pc, #56]	; (ed4 <system_clock_source_get_hz+0x88>)
     e9a:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
     e9c:	4b0a      	ldr	r3, [pc, #40]	; (ec8 <system_clock_source_get_hz+0x7c>)
     e9e:	689b      	ldr	r3, [r3, #8]
     ea0:	041b      	lsls	r3, r3, #16
     ea2:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
     ea4:	4358      	muls	r0, r3
     ea6:	e00c      	b.n	ec2 <system_clock_source_get_hz+0x76>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
     ea8:	2350      	movs	r3, #80	; 0x50
     eaa:	4a08      	ldr	r2, [pc, #32]	; (ecc <system_clock_source_get_hz+0x80>)
     eac:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
     eae:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
     eb0:	075b      	lsls	r3, r3, #29
     eb2:	d506      	bpl.n	ec2 <system_clock_source_get_hz+0x76>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
     eb4:	4b04      	ldr	r3, [pc, #16]	; (ec8 <system_clock_source_get_hz+0x7c>)
     eb6:	68d8      	ldr	r0, [r3, #12]
     eb8:	e003      	b.n	ec2 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
     eba:	2080      	movs	r0, #128	; 0x80
     ebc:	0200      	lsls	r0, r0, #8
     ebe:	e000      	b.n	ec2 <system_clock_source_get_hz+0x76>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
     ec0:	4805      	ldr	r0, [pc, #20]	; (ed8 <system_clock_source_get_hz+0x8c>)
#endif

	default:
		return 0;
	}
}
     ec2:	bd08      	pop	{r3, pc}
     ec4:	000028fc 	.word	0x000028fc
     ec8:	200000a8 	.word	0x200000a8
     ecc:	40000800 	.word	0x40000800
     ed0:	007a1200 	.word	0x007a1200
     ed4:	000012d1 	.word	0x000012d1
     ed8:	02dc6c00 	.word	0x02dc6c00

00000edc <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
     edc:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
     ede:	4c0c      	ldr	r4, [pc, #48]	; (f10 <system_clock_source_osc8m_set_config+0x34>)
     ee0:	6a23      	ldr	r3, [r4, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
     ee2:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
     ee4:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
     ee6:	7842      	ldrb	r2, [r0, #1]
     ee8:	2001      	movs	r0, #1
     eea:	4002      	ands	r2, r0
     eec:	0192      	lsls	r2, r2, #6
     eee:	2640      	movs	r6, #64	; 0x40
     ef0:	43b3      	bics	r3, r6
     ef2:	4313      	orrs	r3, r2
     ef4:	1c02      	adds	r2, r0, #0
     ef6:	402a      	ands	r2, r5
     ef8:	01d2      	lsls	r2, r2, #7
     efa:	307f      	adds	r0, #127	; 0x7f
     efc:	4383      	bics	r3, r0
     efe:	4313      	orrs	r3, r2
     f00:	2203      	movs	r2, #3
     f02:	400a      	ands	r2, r1
     f04:	0212      	lsls	r2, r2, #8
     f06:	4903      	ldr	r1, [pc, #12]	; (f14 <system_clock_source_osc8m_set_config+0x38>)
     f08:	400b      	ands	r3, r1
     f0a:	4313      	orrs	r3, r2
     f0c:	6223      	str	r3, [r4, #32]
}
     f0e:	bd70      	pop	{r4, r5, r6, pc}
     f10:	40000800 	.word	0x40000800
     f14:	fffffcff 	.word	0xfffffcff

00000f18 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
     f18:	2808      	cmp	r0, #8
     f1a:	d803      	bhi.n	f24 <system_clock_source_enable+0xc>
     f1c:	0080      	lsls	r0, r0, #2
     f1e:	4b25      	ldr	r3, [pc, #148]	; (fb4 <system_clock_source_enable+0x9c>)
     f20:	581b      	ldr	r3, [r3, r0]
     f22:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
     f24:	2017      	movs	r0, #23
     f26:	e044      	b.n	fb2 <system_clock_source_enable+0x9a>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
     f28:	4a23      	ldr	r2, [pc, #140]	; (fb8 <system_clock_source_enable+0xa0>)
     f2a:	6a11      	ldr	r1, [r2, #32]
     f2c:	2302      	movs	r3, #2
     f2e:	430b      	orrs	r3, r1
     f30:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
     f32:	2000      	movs	r0, #0
     f34:	e03d      	b.n	fb2 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
     f36:	4a20      	ldr	r2, [pc, #128]	; (fb8 <system_clock_source_enable+0xa0>)
     f38:	6991      	ldr	r1, [r2, #24]
     f3a:	2302      	movs	r3, #2
     f3c:	430b      	orrs	r3, r1
     f3e:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     f40:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
     f42:	e036      	b.n	fb2 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
     f44:	4a1c      	ldr	r2, [pc, #112]	; (fb8 <system_clock_source_enable+0xa0>)
     f46:	8a11      	ldrh	r1, [r2, #16]
     f48:	2302      	movs	r3, #2
     f4a:	430b      	orrs	r3, r1
     f4c:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     f4e:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
     f50:	e02f      	b.n	fb2 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
     f52:	4a19      	ldr	r2, [pc, #100]	; (fb8 <system_clock_source_enable+0xa0>)
     f54:	8a91      	ldrh	r1, [r2, #20]
     f56:	2302      	movs	r3, #2
     f58:	430b      	orrs	r3, r1
     f5a:	8293      	strh	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     f5c:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
     f5e:	e028      	b.n	fb2 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
     f60:	4916      	ldr	r1, [pc, #88]	; (fbc <system_clock_source_enable+0xa4>)
     f62:	680b      	ldr	r3, [r1, #0]
     f64:	2202      	movs	r2, #2
     f66:	4313      	orrs	r3, r2
     f68:	600b      	str	r3, [r1, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
     f6a:	4b13      	ldr	r3, [pc, #76]	; (fb8 <system_clock_source_enable+0xa0>)
     f6c:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
     f6e:	1c19      	adds	r1, r3, #0
     f70:	320e      	adds	r2, #14
     f72:	68cb      	ldr	r3, [r1, #12]
     f74:	421a      	tst	r2, r3
     f76:	d0fc      	beq.n	f72 <system_clock_source_enable+0x5a>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
     f78:	4a10      	ldr	r2, [pc, #64]	; (fbc <system_clock_source_enable+0xa4>)
     f7a:	6891      	ldr	r1, [r2, #8]
     f7c:	4b0e      	ldr	r3, [pc, #56]	; (fb8 <system_clock_source_enable+0xa0>)
     f7e:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
     f80:	6852      	ldr	r2, [r2, #4]
     f82:	629a      	str	r2, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
     f84:	2200      	movs	r2, #0
     f86:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
     f88:	1c19      	adds	r1, r3, #0
     f8a:	3210      	adds	r2, #16
     f8c:	68cb      	ldr	r3, [r1, #12]
     f8e:	421a      	tst	r2, r3
     f90:	d0fc      	beq.n	f8c <system_clock_source_enable+0x74>
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
     f92:	4b0a      	ldr	r3, [pc, #40]	; (fbc <system_clock_source_enable+0xa4>)
     f94:	681b      	ldr	r3, [r3, #0]
     f96:	b29b      	uxth	r3, r3
     f98:	4a07      	ldr	r2, [pc, #28]	; (fb8 <system_clock_source_enable+0xa0>)
     f9a:	8493      	strh	r3, [r2, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     f9c:	2000      	movs	r0, #0
     f9e:	e008      	b.n	fb2 <system_clock_source_enable+0x9a>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
     fa0:	4905      	ldr	r1, [pc, #20]	; (fb8 <system_clock_source_enable+0xa0>)
     fa2:	2244      	movs	r2, #68	; 0x44
     fa4:	5c88      	ldrb	r0, [r1, r2]
     fa6:	2302      	movs	r3, #2
     fa8:	4303      	orrs	r3, r0
     faa:	548b      	strb	r3, [r1, r2]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     fac:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
     fae:	e000      	b.n	fb2 <system_clock_source_enable+0x9a>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
     fb0:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
     fb2:	4770      	bx	lr
     fb4:	00002920 	.word	0x00002920
     fb8:	40000800 	.word	0x40000800
     fbc:	200000a8 	.word	0x200000a8

00000fc0 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
     fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
     fc2:	4647      	mov	r7, r8
     fc4:	b480      	push	{r7}
     fc6:	b084      	sub	sp, #16
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
     fc8:	22c2      	movs	r2, #194	; 0xc2
     fca:	00d2      	lsls	r2, r2, #3
     fcc:	4b22      	ldr	r3, [pc, #136]	; (1058 <system_clock_init+0x98>)
     fce:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
     fd0:	4a22      	ldr	r2, [pc, #136]	; (105c <system_clock_init+0x9c>)
     fd2:	6853      	ldr	r3, [r2, #4]
     fd4:	211e      	movs	r1, #30
     fd6:	438b      	bics	r3, r1
     fd8:	6053      	str	r3, [r2, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
     fda:	2302      	movs	r3, #2
     fdc:	466a      	mov	r2, sp
     fde:	7013      	strb	r3, [r2, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
     fe0:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
     fe2:	4d1f      	ldr	r5, [pc, #124]	; (1060 <system_clock_init+0xa0>)
     fe4:	b2e0      	uxtb	r0, r4
     fe6:	4669      	mov	r1, sp
     fe8:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
     fea:	3401      	adds	r4, #1
     fec:	2c25      	cmp	r4, #37	; 0x25
     fee:	d1f9      	bne.n	fe4 <system_clock_init+0x24>
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
     ff0:	a803      	add	r0, sp, #12
     ff2:	2400      	movs	r4, #0
     ff4:	7044      	strb	r4, [r0, #1]
	config->on_demand       = true;
     ff6:	2501      	movs	r5, #1
     ff8:	7085      	strb	r5, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
     ffa:	7004      	strb	r4, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
     ffc:	4b19      	ldr	r3, [pc, #100]	; (1064 <system_clock_init+0xa4>)
     ffe:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    1000:	2006      	movs	r0, #6
    1002:	4b19      	ldr	r3, [pc, #100]	; (1068 <system_clock_init+0xa8>)
    1004:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    1006:	4b19      	ldr	r3, [pc, #100]	; (106c <system_clock_init+0xac>)
    1008:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    100a:	9501      	str	r5, [sp, #4]
	config->high_when_disabled = false;
    100c:	466b      	mov	r3, sp
    100e:	705c      	strb	r4, [r3, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    1010:	2306      	movs	r3, #6
    1012:	4698      	mov	r8, r3
    1014:	466b      	mov	r3, sp
    1016:	4642      	mov	r2, r8
    1018:	701a      	strb	r2, [r3, #0]
#endif
	config->run_in_standby     = false;
    101a:	721c      	strb	r4, [r3, #8]
	config->output_enable      = false;
    101c:	725c      	strb	r4, [r3, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    101e:	2001      	movs	r0, #1
    1020:	4669      	mov	r1, sp
    1022:	4f13      	ldr	r7, [pc, #76]	; (1070 <system_clock_init+0xb0>)
    1024:	47b8      	blx	r7
    1026:	2001      	movs	r0, #1
    1028:	4e12      	ldr	r6, [pc, #72]	; (1074 <system_clock_init+0xb4>)
    102a:	47b0      	blx	r6
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    102c:	4b12      	ldr	r3, [pc, #72]	; (1078 <system_clock_init+0xb8>)
    102e:	721c      	strb	r4, [r3, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    1030:	725c      	strb	r4, [r3, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    1032:	729c      	strb	r4, [r3, #10]
			break;
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    1034:	72dc      	strb	r4, [r3, #11]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1036:	9501      	str	r5, [sp, #4]
	config->high_when_disabled = false;
    1038:	466b      	mov	r3, sp
    103a:	705c      	strb	r4, [r3, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    103c:	4642      	mov	r2, r8
    103e:	701a      	strb	r2, [r3, #0]
#endif
	config->run_in_standby     = false;
    1040:	721c      	strb	r4, [r3, #8]
	config->output_enable      = false;
    1042:	725c      	strb	r4, [r3, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    1044:	2000      	movs	r0, #0
    1046:	4669      	mov	r1, sp
    1048:	47b8      	blx	r7
    104a:	2000      	movs	r0, #0
    104c:	47b0      	blx	r6
#endif
}
    104e:	b004      	add	sp, #16
    1050:	bc04      	pop	{r2}
    1052:	4690      	mov	r8, r2
    1054:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1056:	46c0      	nop			; (mov r8, r8)
    1058:	40000800 	.word	0x40000800
    105c:	41004000 	.word	0x41004000
    1060:	000012b5 	.word	0x000012b5
    1064:	00000edd 	.word	0x00000edd
    1068:	00000f19 	.word	0x00000f19
    106c:	0000107d 	.word	0x0000107d
    1070:	000010a1 	.word	0x000010a1
    1074:	00001159 	.word	0x00001159
    1078:	40000400 	.word	0x40000400

0000107c <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    107c:	4a06      	ldr	r2, [pc, #24]	; (1098 <system_gclk_init+0x1c>)
    107e:	6991      	ldr	r1, [r2, #24]
    1080:	2308      	movs	r3, #8
    1082:	430b      	orrs	r3, r1
    1084:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    1086:	2201      	movs	r2, #1
    1088:	4b04      	ldr	r3, [pc, #16]	; (109c <system_gclk_init+0x20>)
    108a:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    108c:	1c19      	adds	r1, r3, #0
    108e:	780b      	ldrb	r3, [r1, #0]
    1090:	4213      	tst	r3, r2
    1092:	d1fc      	bne.n	108e <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    1094:	4770      	bx	lr
    1096:	46c0      	nop			; (mov r8, r8)
    1098:	40000400 	.word	0x40000400
    109c:	40000c00 	.word	0x40000c00

000010a0 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    10a0:	b570      	push	{r4, r5, r6, lr}
    10a2:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    10a4:	1c04      	adds	r4, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    10a6:	780d      	ldrb	r5, [r1, #0]
    10a8:	022d      	lsls	r5, r5, #8
    10aa:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    10ac:	784b      	ldrb	r3, [r1, #1]
    10ae:	2b00      	cmp	r3, #0
    10b0:	d002      	beq.n	10b8 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    10b2:	2380      	movs	r3, #128	; 0x80
    10b4:	02db      	lsls	r3, r3, #11
    10b6:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    10b8:	7a4b      	ldrb	r3, [r1, #9]
    10ba:	2b00      	cmp	r3, #0
    10bc:	d002      	beq.n	10c4 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    10be:	2380      	movs	r3, #128	; 0x80
    10c0:	031b      	lsls	r3, r3, #12
    10c2:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    10c4:	6848      	ldr	r0, [r1, #4]
    10c6:	2801      	cmp	r0, #1
    10c8:	d918      	bls.n	10fc <system_gclk_gen_set_config+0x5c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    10ca:	1e43      	subs	r3, r0, #1
    10cc:	4218      	tst	r0, r3
    10ce:	d110      	bne.n	10f2 <system_gclk_gen_set_config+0x52>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    10d0:	2802      	cmp	r0, #2
    10d2:	d906      	bls.n	10e2 <system_gclk_gen_set_config+0x42>
    10d4:	2302      	movs	r3, #2
    10d6:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    10d8:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    10da:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    10dc:	4298      	cmp	r0, r3
    10de:	d8fb      	bhi.n	10d8 <system_gclk_gen_set_config+0x38>
    10e0:	e000      	b.n	10e4 <system_gclk_gen_set_config+0x44>
    10e2:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    10e4:	0212      	lsls	r2, r2, #8
    10e6:	4332      	orrs	r2, r6
    10e8:	1c14      	adds	r4, r2, #0
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    10ea:	2380      	movs	r3, #128	; 0x80
    10ec:	035b      	lsls	r3, r3, #13
    10ee:	431d      	orrs	r5, r3
    10f0:	e004      	b.n	10fc <system_gclk_gen_set_config+0x5c>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    10f2:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    10f4:	4334      	orrs	r4, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    10f6:	2380      	movs	r3, #128	; 0x80
    10f8:	029b      	lsls	r3, r3, #10
    10fa:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    10fc:	7a0b      	ldrb	r3, [r1, #8]
    10fe:	2b00      	cmp	r3, #0
    1100:	d002      	beq.n	1108 <system_gclk_gen_set_config+0x68>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    1102:	2380      	movs	r3, #128	; 0x80
    1104:	039b      	lsls	r3, r3, #14
    1106:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1108:	4a0f      	ldr	r2, [pc, #60]	; (1148 <system_gclk_gen_set_config+0xa8>)
    110a:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    110c:	b25b      	sxtb	r3, r3
    110e:	2b00      	cmp	r3, #0
    1110:	dbfb      	blt.n	110a <system_gclk_gen_set_config+0x6a>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1112:	4b0e      	ldr	r3, [pc, #56]	; (114c <system_gclk_gen_set_config+0xac>)
    1114:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1116:	4b0e      	ldr	r3, [pc, #56]	; (1150 <system_gclk_gen_set_config+0xb0>)
    1118:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    111a:	4a0b      	ldr	r2, [pc, #44]	; (1148 <system_gclk_gen_set_config+0xa8>)
    111c:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    111e:	b25b      	sxtb	r3, r3
    1120:	2b00      	cmp	r3, #0
    1122:	dbfb      	blt.n	111c <system_gclk_gen_set_config+0x7c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    1124:	4b08      	ldr	r3, [pc, #32]	; (1148 <system_gclk_gen_set_config+0xa8>)
    1126:	609c      	str	r4, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1128:	1c1a      	adds	r2, r3, #0
    112a:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    112c:	b25b      	sxtb	r3, r3
    112e:	2b00      	cmp	r3, #0
    1130:	dbfb      	blt.n	112a <system_gclk_gen_set_config+0x8a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    1132:	4a05      	ldr	r2, [pc, #20]	; (1148 <system_gclk_gen_set_config+0xa8>)
    1134:	6851      	ldr	r1, [r2, #4]
    1136:	2380      	movs	r3, #128	; 0x80
    1138:	025b      	lsls	r3, r3, #9
    113a:	400b      	ands	r3, r1
    113c:	431d      	orrs	r5, r3
    113e:	6055      	str	r5, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1140:	4b04      	ldr	r3, [pc, #16]	; (1154 <system_gclk_gen_set_config+0xb4>)
    1142:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1144:	bd70      	pop	{r4, r5, r6, pc}
    1146:	46c0      	nop			; (mov r8, r8)
    1148:	40000c00 	.word	0x40000c00
    114c:	00000d81 	.word	0x00000d81
    1150:	40000c08 	.word	0x40000c08
    1154:	00000dc1 	.word	0x00000dc1

00001158 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    1158:	b510      	push	{r4, lr}
    115a:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    115c:	4a0b      	ldr	r2, [pc, #44]	; (118c <system_gclk_gen_enable+0x34>)
    115e:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    1160:	b25b      	sxtb	r3, r3
    1162:	2b00      	cmp	r3, #0
    1164:	dbfb      	blt.n	115e <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1166:	4b0a      	ldr	r3, [pc, #40]	; (1190 <system_gclk_gen_enable+0x38>)
    1168:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    116a:	4b0a      	ldr	r3, [pc, #40]	; (1194 <system_gclk_gen_enable+0x3c>)
    116c:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    116e:	4a07      	ldr	r2, [pc, #28]	; (118c <system_gclk_gen_enable+0x34>)
    1170:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    1172:	b25b      	sxtb	r3, r3
    1174:	2b00      	cmp	r3, #0
    1176:	dbfb      	blt.n	1170 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    1178:	4a04      	ldr	r2, [pc, #16]	; (118c <system_gclk_gen_enable+0x34>)
    117a:	6853      	ldr	r3, [r2, #4]
    117c:	2180      	movs	r1, #128	; 0x80
    117e:	0249      	lsls	r1, r1, #9
    1180:	430b      	orrs	r3, r1
    1182:	6053      	str	r3, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1184:	4b04      	ldr	r3, [pc, #16]	; (1198 <system_gclk_gen_enable+0x40>)
    1186:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1188:	bd10      	pop	{r4, pc}
    118a:	46c0      	nop			; (mov r8, r8)
    118c:	40000c00 	.word	0x40000c00
    1190:	00000d81 	.word	0x00000d81
    1194:	40000c04 	.word	0x40000c04
    1198:	00000dc1 	.word	0x00000dc1

0000119c <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    119c:	b570      	push	{r4, r5, r6, lr}
    119e:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    11a0:	4a1a      	ldr	r2, [pc, #104]	; (120c <system_gclk_gen_get_hz+0x70>)
    11a2:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    11a4:	b25b      	sxtb	r3, r3
    11a6:	2b00      	cmp	r3, #0
    11a8:	dbfb      	blt.n	11a2 <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    11aa:	4b19      	ldr	r3, [pc, #100]	; (1210 <system_gclk_gen_get_hz+0x74>)
    11ac:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    11ae:	4b19      	ldr	r3, [pc, #100]	; (1214 <system_gclk_gen_get_hz+0x78>)
    11b0:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    11b2:	4a16      	ldr	r2, [pc, #88]	; (120c <system_gclk_gen_get_hz+0x70>)
    11b4:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    11b6:	b25b      	sxtb	r3, r3
    11b8:	2b00      	cmp	r3, #0
    11ba:	dbfb      	blt.n	11b4 <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    11bc:	4e13      	ldr	r6, [pc, #76]	; (120c <system_gclk_gen_get_hz+0x70>)
    11be:	6870      	ldr	r0, [r6, #4]
    11c0:	04c0      	lsls	r0, r0, #19
    11c2:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    11c4:	4b14      	ldr	r3, [pc, #80]	; (1218 <system_gclk_gen_get_hz+0x7c>)
    11c6:	4798      	blx	r3
    11c8:	1c05      	adds	r5, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    11ca:	4b12      	ldr	r3, [pc, #72]	; (1214 <system_gclk_gen_get_hz+0x78>)
    11cc:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    11ce:	6876      	ldr	r6, [r6, #4]
    11d0:	02f6      	lsls	r6, r6, #11
    11d2:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    11d4:	4b11      	ldr	r3, [pc, #68]	; (121c <system_gclk_gen_get_hz+0x80>)
    11d6:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    11d8:	4a0c      	ldr	r2, [pc, #48]	; (120c <system_gclk_gen_get_hz+0x70>)
    11da:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
    11dc:	b25b      	sxtb	r3, r3
    11de:	2b00      	cmp	r3, #0
    11e0:	dbfb      	blt.n	11da <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    11e2:	4b0a      	ldr	r3, [pc, #40]	; (120c <system_gclk_gen_get_hz+0x70>)
    11e4:	689c      	ldr	r4, [r3, #8]
    11e6:	0a24      	lsrs	r4, r4, #8
    11e8:	b2a4      	uxth	r4, r4
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    11ea:	4b0d      	ldr	r3, [pc, #52]	; (1220 <system_gclk_gen_get_hz+0x84>)
    11ec:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    11ee:	2e00      	cmp	r6, #0
    11f0:	d107      	bne.n	1202 <system_gclk_gen_get_hz+0x66>
    11f2:	2c01      	cmp	r4, #1
    11f4:	d907      	bls.n	1206 <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    11f6:	1c28      	adds	r0, r5, #0
    11f8:	1c21      	adds	r1, r4, #0
    11fa:	4b0a      	ldr	r3, [pc, #40]	; (1224 <system_gclk_gen_get_hz+0x88>)
    11fc:	4798      	blx	r3
    11fe:	1c05      	adds	r5, r0, #0
    1200:	e001      	b.n	1206 <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    1202:	3401      	adds	r4, #1
    1204:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    1206:	1c28      	adds	r0, r5, #0
    1208:	bd70      	pop	{r4, r5, r6, pc}
    120a:	46c0      	nop			; (mov r8, r8)
    120c:	40000c00 	.word	0x40000c00
    1210:	00000d81 	.word	0x00000d81
    1214:	40000c04 	.word	0x40000c04
    1218:	00000e4d 	.word	0x00000e4d
    121c:	40000c08 	.word	0x40000c08
    1220:	00000dc1 	.word	0x00000dc1
    1224:	00001721 	.word	0x00001721

00001228 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    1228:	b510      	push	{r4, lr}
    122a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    122c:	4b06      	ldr	r3, [pc, #24]	; (1248 <system_gclk_chan_enable+0x20>)
    122e:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1230:	4b06      	ldr	r3, [pc, #24]	; (124c <system_gclk_chan_enable+0x24>)
    1232:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    1234:	4a06      	ldr	r2, [pc, #24]	; (1250 <system_gclk_chan_enable+0x28>)
    1236:	8851      	ldrh	r1, [r2, #2]
    1238:	2380      	movs	r3, #128	; 0x80
    123a:	01db      	lsls	r3, r3, #7
    123c:	430b      	orrs	r3, r1
    123e:	8053      	strh	r3, [r2, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1240:	4b04      	ldr	r3, [pc, #16]	; (1254 <system_gclk_chan_enable+0x2c>)
    1242:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1244:	bd10      	pop	{r4, pc}
    1246:	46c0      	nop			; (mov r8, r8)
    1248:	00000d81 	.word	0x00000d81
    124c:	40000c02 	.word	0x40000c02
    1250:	40000c00 	.word	0x40000c00
    1254:	00000dc1 	.word	0x00000dc1

00001258 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    1258:	b510      	push	{r4, lr}
    125a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    125c:	4b0f      	ldr	r3, [pc, #60]	; (129c <system_gclk_chan_disable+0x44>)
    125e:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1260:	4b0f      	ldr	r3, [pc, #60]	; (12a0 <system_gclk_chan_disable+0x48>)
    1262:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    1264:	4b0f      	ldr	r3, [pc, #60]	; (12a4 <system_gclk_chan_disable+0x4c>)
    1266:	885a      	ldrh	r2, [r3, #2]
    1268:	0512      	lsls	r2, r2, #20
    126a:	0f10      	lsrs	r0, r2, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    126c:	8859      	ldrh	r1, [r3, #2]
    126e:	4a0e      	ldr	r2, [pc, #56]	; (12a8 <system_gclk_chan_disable+0x50>)
    1270:	400a      	ands	r2, r1
    1272:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    1274:	8859      	ldrh	r1, [r3, #2]
    1276:	4a0d      	ldr	r2, [pc, #52]	; (12ac <system_gclk_chan_disable+0x54>)
    1278:	400a      	ands	r2, r1
    127a:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    127c:	1c19      	adds	r1, r3, #0
    127e:	2280      	movs	r2, #128	; 0x80
    1280:	01d2      	lsls	r2, r2, #7
    1282:	884b      	ldrh	r3, [r1, #2]
    1284:	4213      	tst	r3, r2
    1286:	d1fc      	bne.n	1282 <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    1288:	4906      	ldr	r1, [pc, #24]	; (12a4 <system_gclk_chan_disable+0x4c>)
    128a:	0202      	lsls	r2, r0, #8
    128c:	8848      	ldrh	r0, [r1, #2]
    128e:	4b06      	ldr	r3, [pc, #24]	; (12a8 <system_gclk_chan_disable+0x50>)
    1290:	4003      	ands	r3, r0
    1292:	4313      	orrs	r3, r2
    1294:	804b      	strh	r3, [r1, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1296:	4b06      	ldr	r3, [pc, #24]	; (12b0 <system_gclk_chan_disable+0x58>)
    1298:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    129a:	bd10      	pop	{r4, pc}
    129c:	00000d81 	.word	0x00000d81
    12a0:	40000c02 	.word	0x40000c02
    12a4:	40000c00 	.word	0x40000c00
    12a8:	fffff0ff 	.word	0xfffff0ff
    12ac:	ffffbfff 	.word	0xffffbfff
    12b0:	00000dc1 	.word	0x00000dc1

000012b4 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    12b4:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    12b6:	780c      	ldrb	r4, [r1, #0]
    12b8:	0224      	lsls	r4, r4, #8
    12ba:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    12bc:	4b02      	ldr	r3, [pc, #8]	; (12c8 <system_gclk_chan_set_config+0x14>)
    12be:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    12c0:	b2a4      	uxth	r4, r4
    12c2:	4b02      	ldr	r3, [pc, #8]	; (12cc <system_gclk_chan_set_config+0x18>)
    12c4:	805c      	strh	r4, [r3, #2]
}
    12c6:	bd10      	pop	{r4, pc}
    12c8:	00001259 	.word	0x00001259
    12cc:	40000c00 	.word	0x40000c00

000012d0 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    12d0:	b510      	push	{r4, lr}
    12d2:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    12d4:	4b06      	ldr	r3, [pc, #24]	; (12f0 <system_gclk_chan_get_hz+0x20>)
    12d6:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    12d8:	4b06      	ldr	r3, [pc, #24]	; (12f4 <system_gclk_chan_get_hz+0x24>)
    12da:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    12dc:	4b06      	ldr	r3, [pc, #24]	; (12f8 <system_gclk_chan_get_hz+0x28>)
    12de:	885c      	ldrh	r4, [r3, #2]
    12e0:	0524      	lsls	r4, r4, #20
    12e2:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    12e4:	4b05      	ldr	r3, [pc, #20]	; (12fc <system_gclk_chan_get_hz+0x2c>)
    12e6:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    12e8:	1c20      	adds	r0, r4, #0
    12ea:	4b05      	ldr	r3, [pc, #20]	; (1300 <system_gclk_chan_get_hz+0x30>)
    12ec:	4798      	blx	r3
}
    12ee:	bd10      	pop	{r4, pc}
    12f0:	00000d81 	.word	0x00000d81
    12f4:	40000c02 	.word	0x40000c02
    12f8:	40000c00 	.word	0x40000c00
    12fc:	00000dc1 	.word	0x00000dc1
    1300:	0000119d 	.word	0x0000119d

00001304 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    1304:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    1306:	78d3      	ldrb	r3, [r2, #3]
    1308:	2b00      	cmp	r3, #0
    130a:	d11e      	bne.n	134a <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    130c:	7814      	ldrb	r4, [r2, #0]
    130e:	2c80      	cmp	r4, #128	; 0x80
    1310:	d004      	beq.n	131c <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    1312:	0624      	lsls	r4, r4, #24
    1314:	2380      	movs	r3, #128	; 0x80
    1316:	025b      	lsls	r3, r3, #9
    1318:	431c      	orrs	r4, r3
    131a:	e000      	b.n	131e <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    131c:	2400      	movs	r4, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    131e:	7853      	ldrb	r3, [r2, #1]
    1320:	2502      	movs	r5, #2
    1322:	43ab      	bics	r3, r5
    1324:	d10a      	bne.n	133c <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    1326:	7893      	ldrb	r3, [r2, #2]
    1328:	2b00      	cmp	r3, #0
    132a:	d103      	bne.n	1334 <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    132c:	2380      	movs	r3, #128	; 0x80
    132e:	029b      	lsls	r3, r3, #10
    1330:	431c      	orrs	r4, r3
    1332:	e002      	b.n	133a <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    1334:	23c0      	movs	r3, #192	; 0xc0
    1336:	02db      	lsls	r3, r3, #11
    1338:	431c      	orrs	r4, r3
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    133a:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    133c:	7853      	ldrb	r3, [r2, #1]
    133e:	3b01      	subs	r3, #1
    1340:	2b01      	cmp	r3, #1
    1342:	d812      	bhi.n	136a <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    1344:	4b18      	ldr	r3, [pc, #96]	; (13a8 <_system_pinmux_config+0xa4>)
    1346:	401c      	ands	r4, r3
    1348:	e00f      	b.n	136a <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    134a:	6041      	str	r1, [r0, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    134c:	040b      	lsls	r3, r1, #16
    134e:	0c1b      	lsrs	r3, r3, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1350:	24a0      	movs	r4, #160	; 0xa0
    1352:	05e4      	lsls	r4, r4, #23
    1354:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1356:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    1358:	0c0b      	lsrs	r3, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    135a:	24d0      	movs	r4, #208	; 0xd0
    135c:	0624      	lsls	r4, r4, #24
    135e:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1360:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    1362:	78d3      	ldrb	r3, [r2, #3]
    1364:	2b00      	cmp	r3, #0
    1366:	d018      	beq.n	139a <_system_pinmux_config+0x96>
    1368:	e01c      	b.n	13a4 <_system_pinmux_config+0xa0>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    136a:	040b      	lsls	r3, r1, #16
    136c:	0c1b      	lsrs	r3, r3, #16
    136e:	25a0      	movs	r5, #160	; 0xa0
    1370:	05ed      	lsls	r5, r5, #23
    1372:	432b      	orrs	r3, r5

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1374:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1376:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    1378:	0c0b      	lsrs	r3, r1, #16
    137a:	25d0      	movs	r5, #208	; 0xd0
    137c:	062d      	lsls	r5, r5, #24
    137e:	432b      	orrs	r3, r5

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1380:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1382:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    1384:	78d3      	ldrb	r3, [r2, #3]
    1386:	2b00      	cmp	r3, #0
    1388:	d10c      	bne.n	13a4 <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    138a:	0363      	lsls	r3, r4, #13
    138c:	d505      	bpl.n	139a <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    138e:	7893      	ldrb	r3, [r2, #2]
    1390:	2b01      	cmp	r3, #1
    1392:	d101      	bne.n	1398 <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
    1394:	6181      	str	r1, [r0, #24]
    1396:	e000      	b.n	139a <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
    1398:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    139a:	7853      	ldrb	r3, [r2, #1]
    139c:	3b01      	subs	r3, #1
    139e:	2b01      	cmp	r3, #1
    13a0:	d800      	bhi.n	13a4 <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    13a2:	6081      	str	r1, [r0, #8]
		}
	}
}
    13a4:	bd30      	pop	{r4, r5, pc}
    13a6:	46c0      	nop			; (mov r8, r8)
    13a8:	fffbffff 	.word	0xfffbffff

000013ac <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    13ac:	b508      	push	{r3, lr}
    13ae:	1c03      	adds	r3, r0, #0
    13b0:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    13b2:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    13b4:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    13b6:	2900      	cmp	r1, #0
    13b8:	d104      	bne.n	13c4 <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
    13ba:	0958      	lsrs	r0, r3, #5
    13bc:	01c0      	lsls	r0, r0, #7
    13be:	4905      	ldr	r1, [pc, #20]	; (13d4 <system_pinmux_pin_set_config+0x28>)
    13c0:	468c      	mov	ip, r1
    13c2:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    13c4:	211f      	movs	r1, #31
    13c6:	400b      	ands	r3, r1
    13c8:	391e      	subs	r1, #30
    13ca:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    13cc:	4b02      	ldr	r3, [pc, #8]	; (13d8 <system_pinmux_pin_set_config+0x2c>)
    13ce:	4798      	blx	r3
}
    13d0:	bd08      	pop	{r3, pc}
    13d2:	46c0      	nop			; (mov r8, r8)
    13d4:	41004400 	.word	0x41004400
    13d8:	00001305 	.word	0x00001305

000013dc <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    13dc:	4770      	bx	lr
    13de:	46c0      	nop			; (mov r8, r8)

000013e0 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    13e0:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    13e2:	4b05      	ldr	r3, [pc, #20]	; (13f8 <system_init+0x18>)
    13e4:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    13e6:	4b05      	ldr	r3, [pc, #20]	; (13fc <system_init+0x1c>)
    13e8:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    13ea:	4b05      	ldr	r3, [pc, #20]	; (1400 <system_init+0x20>)
    13ec:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    13ee:	4b05      	ldr	r3, [pc, #20]	; (1404 <system_init+0x24>)
    13f0:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    13f2:	4b05      	ldr	r3, [pc, #20]	; (1408 <system_init+0x28>)
    13f4:	4798      	blx	r3
}
    13f6:	bd08      	pop	{r3, pc}
    13f8:	00000fc1 	.word	0x00000fc1
    13fc:	00000df1 	.word	0x00000df1
    1400:	000013dd 	.word	0x000013dd
    1404:	000013dd 	.word	0x000013dd
    1408:	000013dd 	.word	0x000013dd

0000140c <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
    140c:	e7fe      	b.n	140c <Dummy_Handler>
    140e:	46c0      	nop			; (mov r8, r8)

00001410 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    1410:	b570      	push	{r4, r5, r6, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    1412:	4b2e      	ldr	r3, [pc, #184]	; (14cc <Reset_Handler+0xbc>)
    1414:	4a2e      	ldr	r2, [pc, #184]	; (14d0 <Reset_Handler+0xc0>)
    1416:	429a      	cmp	r2, r3
    1418:	d003      	beq.n	1422 <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
    141a:	4b2e      	ldr	r3, [pc, #184]	; (14d4 <Reset_Handler+0xc4>)
    141c:	4a2b      	ldr	r2, [pc, #172]	; (14cc <Reset_Handler+0xbc>)
    141e:	429a      	cmp	r2, r3
    1420:	d304      	bcc.n	142c <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1422:	4b2d      	ldr	r3, [pc, #180]	; (14d8 <Reset_Handler+0xc8>)
    1424:	4a2d      	ldr	r2, [pc, #180]	; (14dc <Reset_Handler+0xcc>)
    1426:	429a      	cmp	r2, r3
    1428:	d310      	bcc.n	144c <Reset_Handler+0x3c>
    142a:	e01e      	b.n	146a <Reset_Handler+0x5a>
    142c:	4a2c      	ldr	r2, [pc, #176]	; (14e0 <Reset_Handler+0xd0>)
    142e:	4b29      	ldr	r3, [pc, #164]	; (14d4 <Reset_Handler+0xc4>)
    1430:	3303      	adds	r3, #3
    1432:	1a9b      	subs	r3, r3, r2
    1434:	089b      	lsrs	r3, r3, #2
    1436:	3301      	adds	r3, #1
    1438:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    143a:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    143c:	4823      	ldr	r0, [pc, #140]	; (14cc <Reset_Handler+0xbc>)
    143e:	4924      	ldr	r1, [pc, #144]	; (14d0 <Reset_Handler+0xc0>)
    1440:	588c      	ldr	r4, [r1, r2]
    1442:	5084      	str	r4, [r0, r2]
    1444:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    1446:	429a      	cmp	r2, r3
    1448:	d1fa      	bne.n	1440 <Reset_Handler+0x30>
    144a:	e7ea      	b.n	1422 <Reset_Handler+0x12>
    144c:	4a25      	ldr	r2, [pc, #148]	; (14e4 <Reset_Handler+0xd4>)
    144e:	4b22      	ldr	r3, [pc, #136]	; (14d8 <Reset_Handler+0xc8>)
    1450:	3303      	adds	r3, #3
    1452:	1a9b      	subs	r3, r3, r2
    1454:	089b      	lsrs	r3, r3, #2
    1456:	3301      	adds	r3, #1
    1458:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    145a:	2200      	movs	r2, #0
                *pDest++ = 0;
    145c:	481f      	ldr	r0, [pc, #124]	; (14dc <Reset_Handler+0xcc>)
    145e:	2100      	movs	r1, #0
    1460:	1814      	adds	r4, r2, r0
    1462:	6021      	str	r1, [r4, #0]
    1464:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1466:	429a      	cmp	r2, r3
    1468:	d1fa      	bne.n	1460 <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    146a:	4a1f      	ldr	r2, [pc, #124]	; (14e8 <Reset_Handler+0xd8>)
    146c:	21ff      	movs	r1, #255	; 0xff
    146e:	4b1f      	ldr	r3, [pc, #124]	; (14ec <Reset_Handler+0xdc>)
    1470:	438b      	bics	r3, r1
    1472:	6093      	str	r3, [r2, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    1474:	39fd      	subs	r1, #253	; 0xfd
    1476:	2390      	movs	r3, #144	; 0x90
    1478:	005b      	lsls	r3, r3, #1
    147a:	4a1d      	ldr	r2, [pc, #116]	; (14f0 <Reset_Handler+0xe0>)
    147c:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    147e:	481d      	ldr	r0, [pc, #116]	; (14f4 <Reset_Handler+0xe4>)
    1480:	78c3      	ldrb	r3, [r0, #3]
    1482:	2403      	movs	r4, #3
    1484:	43a3      	bics	r3, r4
    1486:	2202      	movs	r2, #2
    1488:	4313      	orrs	r3, r2
    148a:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    148c:	78c3      	ldrb	r3, [r0, #3]
    148e:	260c      	movs	r6, #12
    1490:	43b3      	bics	r3, r6
    1492:	2108      	movs	r1, #8
    1494:	430b      	orrs	r3, r1
    1496:	70c3      	strb	r3, [r0, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    1498:	4b17      	ldr	r3, [pc, #92]	; (14f8 <Reset_Handler+0xe8>)
    149a:	7b98      	ldrb	r0, [r3, #14]
    149c:	2530      	movs	r5, #48	; 0x30
    149e:	43a8      	bics	r0, r5
    14a0:	1c05      	adds	r5, r0, #0
    14a2:	2020      	movs	r0, #32
    14a4:	4328      	orrs	r0, r5
    14a6:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    14a8:	7b98      	ldrb	r0, [r3, #14]
    14aa:	43b0      	bics	r0, r6
    14ac:	4301      	orrs	r1, r0
    14ae:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    14b0:	7b99      	ldrb	r1, [r3, #14]
    14b2:	43a1      	bics	r1, r4
    14b4:	430a      	orrs	r2, r1
    14b6:	739a      	strb	r2, [r3, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    14b8:	4a10      	ldr	r2, [pc, #64]	; (14fc <Reset_Handler+0xec>)
    14ba:	6851      	ldr	r1, [r2, #4]
    14bc:	2380      	movs	r3, #128	; 0x80
    14be:	430b      	orrs	r3, r1
    14c0:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    14c2:	4b0f      	ldr	r3, [pc, #60]	; (1500 <Reset_Handler+0xf0>)
    14c4:	4798      	blx	r3

        /* Branch to main function */
        main();
    14c6:	4b0f      	ldr	r3, [pc, #60]	; (1504 <Reset_Handler+0xf4>)
    14c8:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    14ca:	e7fe      	b.n	14ca <Reset_Handler+0xba>
    14cc:	20000000 	.word	0x20000000
    14d0:	00002a18 	.word	0x00002a18
    14d4:	20000068 	.word	0x20000068
    14d8:	20000128 	.word	0x20000128
    14dc:	20000068 	.word	0x20000068
    14e0:	20000004 	.word	0x20000004
    14e4:	2000006c 	.word	0x2000006c
    14e8:	e000ed00 	.word	0xe000ed00
    14ec:	00000000 	.word	0x00000000
    14f0:	41007000 	.word	0x41007000
    14f4:	41005000 	.word	0x41005000
    14f8:	41004800 	.word	0x41004800
    14fc:	41004000 	.word	0x41004000
    1500:	00001899 	.word	0x00001899
    1504:	00001681 	.word	0x00001681

00001508 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    1508:	1c03      	adds	r3, r0, #0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    150a:	4a06      	ldr	r2, [pc, #24]	; (1524 <_sbrk+0x1c>)
    150c:	6812      	ldr	r2, [r2, #0]
    150e:	2a00      	cmp	r2, #0
    1510:	d102      	bne.n	1518 <_sbrk+0x10>
		heap = (unsigned char *)&_end;
    1512:	4905      	ldr	r1, [pc, #20]	; (1528 <_sbrk+0x20>)
    1514:	4a03      	ldr	r2, [pc, #12]	; (1524 <_sbrk+0x1c>)
    1516:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
    1518:	4a02      	ldr	r2, [pc, #8]	; (1524 <_sbrk+0x1c>)
    151a:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    151c:	18c3      	adds	r3, r0, r3
    151e:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    1520:	4770      	bx	lr
    1522:	46c0      	nop			; (mov r8, r8)
    1524:	200000c0 	.word	0x200000c0
    1528:	20002128 	.word	0x20002128

0000152c <_close>:
}

extern int _close(int file)
{
	return -1;
}
    152c:	2001      	movs	r0, #1
    152e:	4240      	negs	r0, r0
    1530:	4770      	bx	lr
    1532:	46c0      	nop			; (mov r8, r8)

00001534 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    1534:	2380      	movs	r3, #128	; 0x80
    1536:	019b      	lsls	r3, r3, #6
    1538:	604b      	str	r3, [r1, #4]

	return 0;
}
    153a:	2000      	movs	r0, #0
    153c:	4770      	bx	lr
    153e:	46c0      	nop			; (mov r8, r8)

00001540 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
    1540:	2001      	movs	r0, #1
    1542:	4770      	bx	lr

00001544 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
    1544:	2000      	movs	r0, #0
    1546:	4770      	bx	lr

00001548 <usart_serial_getchar>:
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    1548:	b570      	push	{r4, r5, r6, lr}
    154a:	b082      	sub	sp, #8
    154c:	1c05      	adds	r5, r0, #0
    154e:	1c0e      	adds	r6, r1, #0
	uint16_t temp = 0;
    1550:	2200      	movs	r2, #0
    1552:	466b      	mov	r3, sp
    1554:	80da      	strh	r2, [r3, #6]

	while(STATUS_OK != usart_read_wait(module, &temp));
    1556:	4c06      	ldr	r4, [pc, #24]	; (1570 <usart_serial_getchar+0x28>)
    1558:	1c28      	adds	r0, r5, #0
    155a:	466b      	mov	r3, sp
    155c:	1d99      	adds	r1, r3, #6
    155e:	47a0      	blx	r4
    1560:	2800      	cmp	r0, #0
    1562:	d1f9      	bne.n	1558 <usart_serial_getchar+0x10>

	*c = temp;
    1564:	466b      	mov	r3, sp
    1566:	3306      	adds	r3, #6
    1568:	881b      	ldrh	r3, [r3, #0]
    156a:	7033      	strb	r3, [r6, #0]
}
    156c:	b002      	add	sp, #8
    156e:	bd70      	pop	{r4, r5, r6, pc}
    1570:	00000a9d 	.word	0x00000a9d

00001574 <usart_serial_putchar>:
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(
		struct usart_module *const module,
		uint8_t c)
{
    1574:	b570      	push	{r4, r5, r6, lr}
    1576:	1c05      	adds	r5, r0, #0
	while(STATUS_OK !=usart_write_wait(module, c));
    1578:	b28c      	uxth	r4, r1
    157a:	4e03      	ldr	r6, [pc, #12]	; (1588 <usart_serial_putchar+0x14>)
    157c:	1c28      	adds	r0, r5, #0
    157e:	1c21      	adds	r1, r4, #0
    1580:	47b0      	blx	r6
    1582:	2800      	cmp	r0, #0
    1584:	d1fa      	bne.n	157c <usart_serial_putchar+0x8>

	return STATUS_OK;
}
    1586:	bd70      	pop	{r4, r5, r6, pc}
    1588:	00000a71 	.word	0x00000a71

0000158c <configure_console>:
* SERCOM instance	-> 3
* BAUDRATE			-> 9600
*/

void configure_console(void)
{
    158c:	b5f0      	push	{r4, r5, r6, r7, lr}
    158e:	b091      	sub	sp, #68	; 0x44
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    1590:	2380      	movs	r3, #128	; 0x80
    1592:	05db      	lsls	r3, r3, #23
    1594:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    1596:	2300      	movs	r3, #0
    1598:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    159a:	22ff      	movs	r2, #255	; 0xff
    159c:	4669      	mov	r1, sp
    159e:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    15a0:	2200      	movs	r2, #0
    15a2:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    15a4:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
    15a6:	2196      	movs	r1, #150	; 0x96
    15a8:	0189      	lsls	r1, r1, #6
    15aa:	9108      	str	r1, [sp, #32]
	config->receiver_enable  = true;
    15ac:	2401      	movs	r4, #1
    15ae:	2124      	movs	r1, #36	; 0x24
    15b0:	4668      	mov	r0, sp
    15b2:	5444      	strb	r4, [r0, r1]
	config->transmitter_enable = true;
    15b4:	3101      	adds	r1, #1
    15b6:	5444      	strb	r4, [r0, r1]
	config->clock_polarity_inverted = false;
    15b8:	3101      	adds	r1, #1
    15ba:	5443      	strb	r3, [r0, r1]
	config->use_external_clock = false;
    15bc:	3101      	adds	r1, #1
    15be:	5443      	strb	r3, [r0, r1]
	config->ext_clock_freq   = 0;
    15c0:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    15c2:	3105      	adds	r1, #5
    15c4:	5443      	strb	r3, [r0, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    15c6:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    15c8:	8203      	strh	r3, [r0, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    15ca:	76c3      	strb	r3, [r0, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    15cc:	7602      	strb	r2, [r0, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    15ce:	7702      	strb	r2, [r0, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    15d0:	7642      	strb	r2, [r0, #25]
	config->receive_pulse_length                    = 19;
    15d2:	2313      	movs	r3, #19
    15d4:	7683      	strb	r3, [r0, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    15d6:	7742      	strb	r2, [r0, #29]
	
	struct usart_config conf_usart;
	
	usart_get_config_defaults(&conf_usart);
	
	conf_usart.generator_source = GCLK_GENERATOR_1;
    15d8:	232d      	movs	r3, #45	; 0x2d
    15da:	54c4      	strb	r4, [r0, r3]
	conf_usart.baudrate = 9600;
	conf_usart.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    15dc:	2380      	movs	r3, #128	; 0x80
    15de:	035b      	lsls	r3, r3, #13
    15e0:	9303      	str	r3, [sp, #12]
	
	conf_usart.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    15e2:	4b19      	ldr	r3, [pc, #100]	; (1648 <configure_console+0xbc>)
    15e4:	930c      	str	r3, [sp, #48]	; 0x30
	conf_usart.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    15e6:	4b19      	ldr	r3, [pc, #100]	; (164c <configure_console+0xc0>)
    15e8:	930d      	str	r3, [sp, #52]	; 0x34
	conf_usart.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    15ea:	2301      	movs	r3, #1
    15ec:	425b      	negs	r3, r3
    15ee:	930e      	str	r3, [sp, #56]	; 0x38
	conf_usart.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    15f0:	930f      	str	r3, [sp, #60]	; 0x3c
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    15f2:	4d17      	ldr	r5, [pc, #92]	; (1650 <configure_console+0xc4>)
    15f4:	4b17      	ldr	r3, [pc, #92]	; (1654 <configure_console+0xc8>)
    15f6:	601d      	str	r5, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    15f8:	4a17      	ldr	r2, [pc, #92]	; (1658 <configure_console+0xcc>)
    15fa:	4b18      	ldr	r3, [pc, #96]	; (165c <configure_console+0xd0>)
    15fc:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    15fe:	4a18      	ldr	r2, [pc, #96]	; (1660 <configure_console+0xd4>)
    1600:	4b18      	ldr	r3, [pc, #96]	; (1664 <configure_console+0xd8>)
    1602:	601a      	str	r2, [r3, #0]
static inline bool usart_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	if (usart_init(module, hw, config) == STATUS_OK) {
    1604:	1c28      	adds	r0, r5, #0
    1606:	4918      	ldr	r1, [pc, #96]	; (1668 <configure_console+0xdc>)
    1608:	466a      	mov	r2, sp
    160a:	4b18      	ldr	r3, [pc, #96]	; (166c <configure_console+0xe0>)
    160c:	4798      	blx	r3

	usart_serial_init(module, hw, config);
# if defined(__GNUC__)
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    160e:	4f18      	ldr	r7, [pc, #96]	; (1670 <configure_console+0xe4>)
    1610:	683b      	ldr	r3, [r7, #0]
    1612:	6898      	ldr	r0, [r3, #8]
    1614:	2100      	movs	r1, #0
    1616:	4e17      	ldr	r6, [pc, #92]	; (1674 <configure_console+0xe8>)
    1618:	47b0      	blx	r6
	setbuf(stdin, NULL);
    161a:	683b      	ldr	r3, [r7, #0]
    161c:	6858      	ldr	r0, [r3, #4]
    161e:	2100      	movs	r1, #0
    1620:	47b0      	blx	r6
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    1622:	682e      	ldr	r6, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    1624:	1c30      	adds	r0, r6, #0
    1626:	4b14      	ldr	r3, [pc, #80]	; (1678 <configure_console+0xec>)
    1628:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    162a:	231f      	movs	r3, #31
    162c:	4018      	ands	r0, r3
    162e:	4084      	lsls	r4, r0
    1630:	4b12      	ldr	r3, [pc, #72]	; (167c <configure_console+0xf0>)
    1632:	601c      	str	r4, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    1634:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    1636:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1638:	2b00      	cmp	r3, #0
    163a:	d1fc      	bne.n	1636 <configure_console+0xaa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    163c:	6832      	ldr	r2, [r6, #0]
    163e:	3302      	adds	r3, #2
    1640:	4313      	orrs	r3, r2
    1642:	6033      	str	r3, [r6, #0]
	
	stdio_serial_init(&console_instance, EDBG_CDC_MODULE, &conf_usart);
	
	usart_enable(&console_instance);
}
    1644:	b011      	add	sp, #68	; 0x44
    1646:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1648:	00160002 	.word	0x00160002
    164c:	00170002 	.word	0x00170002
    1650:	200000f0 	.word	0x200000f0
    1654:	200000d4 	.word	0x200000d4
    1658:	00001575 	.word	0x00001575
    165c:	200000d0 	.word	0x200000d0
    1660:	00001549 	.word	0x00001549
    1664:	200000cc 	.word	0x200000cc
    1668:	42001400 	.word	0x42001400
    166c:	00000739 	.word	0x00000739
    1670:	20000064 	.word	0x20000064
    1674:	00001965 	.word	0x00001965
    1678:	00000cf5 	.word	0x00000cf5
    167c:	e000e100 	.word	0xe000e100

00001680 <main>:

int main (void)
{
    1680:	b5f0      	push	{r4, r5, r6, r7, lr}
    1682:	b083      	sub	sp, #12
	uint8_t tiles[6] = {0,0,0,0,0,0}, receivedData,i = 0;
    1684:	2300      	movs	r3, #0
    1686:	466a      	mov	r2, sp
    1688:	7013      	strb	r3, [r2, #0]
    168a:	7053      	strb	r3, [r2, #1]
    168c:	7093      	strb	r3, [r2, #2]
    168e:	70d3      	strb	r3, [r2, #3]
    1690:	7113      	strb	r3, [r2, #4]
    1692:	7153      	strb	r3, [r2, #5]
	int quotient;
	system_init();
    1694:	4b18      	ldr	r3, [pc, #96]	; (16f8 <main+0x78>)
    1696:	4798      	blx	r3
	ext_usart_clock_init();
    1698:	4b18      	ldr	r3, [pc, #96]	; (16fc <main+0x7c>)
    169a:	4798      	blx	r3
	ext_usart_pin_init();
    169c:	4b18      	ldr	r3, [pc, #96]	; (1700 <main+0x80>)
    169e:	4798      	blx	r3
	ext_usart_init();
    16a0:	4b18      	ldr	r3, [pc, #96]	; (1704 <main+0x84>)
    16a2:	4798      	blx	r3
	configure_console();
    16a4:	4b18      	ldr	r3, [pc, #96]	; (1708 <main+0x88>)
    16a6:	4798      	blx	r3
	printf("Up and running!\r");
    16a8:	4818      	ldr	r0, [pc, #96]	; (170c <main+0x8c>)
    16aa:	4b19      	ldr	r3, [pc, #100]	; (1710 <main+0x90>)
    16ac:	4798      	blx	r3
	while (1) {
		receivedData = USART_Receive();
    16ae:	4e19      	ldr	r6, [pc, #100]	; (1714 <main+0x94>)
			tiles[i] = quotient%2;
			quotient /= 2;
			i++;
		}
		for(int i = 0; i < 6; i++) {
			printf("%d",tiles[i]);
    16b0:	4d17      	ldr	r5, [pc, #92]	; (1710 <main+0x90>)
	ext_usart_pin_init();
	ext_usart_init();
	configure_console();
	printf("Up and running!\r");
	while (1) {
		receivedData = USART_Receive();
    16b2:	47b0      	blx	r6
		quotient = receivedData;
		i = 0;
		while(quotient != 0) {
    16b4:	2800      	cmp	r0, #0
    16b6:	d01c      	beq.n	16f2 <main+0x72>
    16b8:	2200      	movs	r2, #0
			tiles[i] = quotient%2;
    16ba:	2701      	movs	r7, #1
    16bc:	0fc1      	lsrs	r1, r0, #31
    16be:	1843      	adds	r3, r0, r1
    16c0:	403b      	ands	r3, r7
    16c2:	1a5b      	subs	r3, r3, r1
    16c4:	4669      	mov	r1, sp
    16c6:	548b      	strb	r3, [r1, r2]
			quotient /= 2;
    16c8:	0fc3      	lsrs	r3, r0, #31
    16ca:	1818      	adds	r0, r3, r0
    16cc:	1040      	asrs	r0, r0, #1
			i++;
    16ce:	3201      	adds	r2, #1
    16d0:	b2d2      	uxtb	r2, r2
	printf("Up and running!\r");
	while (1) {
		receivedData = USART_Receive();
		quotient = receivedData;
		i = 0;
		while(quotient != 0) {
    16d2:	2800      	cmp	r0, #0
    16d4:	d1f2      	bne.n	16bc <main+0x3c>
    16d6:	e00c      	b.n	16f2 <main+0x72>
			tiles[i] = quotient%2;
			quotient /= 2;
			i++;
		}
		for(int i = 0; i < 6; i++) {
			printf("%d",tiles[i]);
    16d8:	466b      	mov	r3, sp
    16da:	5cf9      	ldrb	r1, [r7, r3]
    16dc:	480e      	ldr	r0, [pc, #56]	; (1718 <main+0x98>)
    16de:	47a8      	blx	r5
			tiles[i] = 0;
    16e0:	466b      	mov	r3, sp
    16e2:	54fc      	strb	r4, [r7, r3]
		while(quotient != 0) {
			tiles[i] = quotient%2;
			quotient /= 2;
			i++;
		}
		for(int i = 0; i < 6; i++) {
    16e4:	3701      	adds	r7, #1
    16e6:	2f06      	cmp	r7, #6
    16e8:	d1f6      	bne.n	16d8 <main+0x58>
			printf("%d",tiles[i]);
			tiles[i] = 0;
		}
	printf("\n");
    16ea:	200a      	movs	r0, #10
    16ec:	4b0b      	ldr	r3, [pc, #44]	; (171c <main+0x9c>)
    16ee:	4798      	blx	r3
	}
    16f0:	e7df      	b.n	16b2 <main+0x32>
	printf("Up and running!\r");
	while (1) {
		receivedData = USART_Receive();
		quotient = receivedData;
		i = 0;
		while(quotient != 0) {
    16f2:	2700      	movs	r7, #0
			quotient /= 2;
			i++;
		}
		for(int i = 0; i < 6; i++) {
			printf("%d",tiles[i]);
			tiles[i] = 0;
    16f4:	2400      	movs	r4, #0
    16f6:	e7ef      	b.n	16d8 <main+0x58>
    16f8:	000013e1 	.word	0x000013e1
    16fc:	0000065d 	.word	0x0000065d
    1700:	0000068d 	.word	0x0000068d
    1704:	000006cd 	.word	0x000006cd
    1708:	0000158d 	.word	0x0000158d
    170c:	00002944 	.word	0x00002944
    1710:	00001909 	.word	0x00001909
    1714:	00000721 	.word	0x00000721
    1718:	00002958 	.word	0x00002958
    171c:	0000193d 	.word	0x0000193d

00001720 <__aeabi_uidiv>:
    1720:	2200      	movs	r2, #0
    1722:	0843      	lsrs	r3, r0, #1
    1724:	428b      	cmp	r3, r1
    1726:	d374      	bcc.n	1812 <__aeabi_uidiv+0xf2>
    1728:	0903      	lsrs	r3, r0, #4
    172a:	428b      	cmp	r3, r1
    172c:	d35f      	bcc.n	17ee <__aeabi_uidiv+0xce>
    172e:	0a03      	lsrs	r3, r0, #8
    1730:	428b      	cmp	r3, r1
    1732:	d344      	bcc.n	17be <__aeabi_uidiv+0x9e>
    1734:	0b03      	lsrs	r3, r0, #12
    1736:	428b      	cmp	r3, r1
    1738:	d328      	bcc.n	178c <__aeabi_uidiv+0x6c>
    173a:	0c03      	lsrs	r3, r0, #16
    173c:	428b      	cmp	r3, r1
    173e:	d30d      	bcc.n	175c <__aeabi_uidiv+0x3c>
    1740:	22ff      	movs	r2, #255	; 0xff
    1742:	0209      	lsls	r1, r1, #8
    1744:	ba12      	rev	r2, r2
    1746:	0c03      	lsrs	r3, r0, #16
    1748:	428b      	cmp	r3, r1
    174a:	d302      	bcc.n	1752 <__aeabi_uidiv+0x32>
    174c:	1212      	asrs	r2, r2, #8
    174e:	0209      	lsls	r1, r1, #8
    1750:	d065      	beq.n	181e <__aeabi_uidiv+0xfe>
    1752:	0b03      	lsrs	r3, r0, #12
    1754:	428b      	cmp	r3, r1
    1756:	d319      	bcc.n	178c <__aeabi_uidiv+0x6c>
    1758:	e000      	b.n	175c <__aeabi_uidiv+0x3c>
    175a:	0a09      	lsrs	r1, r1, #8
    175c:	0bc3      	lsrs	r3, r0, #15
    175e:	428b      	cmp	r3, r1
    1760:	d301      	bcc.n	1766 <__aeabi_uidiv+0x46>
    1762:	03cb      	lsls	r3, r1, #15
    1764:	1ac0      	subs	r0, r0, r3
    1766:	4152      	adcs	r2, r2
    1768:	0b83      	lsrs	r3, r0, #14
    176a:	428b      	cmp	r3, r1
    176c:	d301      	bcc.n	1772 <__aeabi_uidiv+0x52>
    176e:	038b      	lsls	r3, r1, #14
    1770:	1ac0      	subs	r0, r0, r3
    1772:	4152      	adcs	r2, r2
    1774:	0b43      	lsrs	r3, r0, #13
    1776:	428b      	cmp	r3, r1
    1778:	d301      	bcc.n	177e <__aeabi_uidiv+0x5e>
    177a:	034b      	lsls	r3, r1, #13
    177c:	1ac0      	subs	r0, r0, r3
    177e:	4152      	adcs	r2, r2
    1780:	0b03      	lsrs	r3, r0, #12
    1782:	428b      	cmp	r3, r1
    1784:	d301      	bcc.n	178a <__aeabi_uidiv+0x6a>
    1786:	030b      	lsls	r3, r1, #12
    1788:	1ac0      	subs	r0, r0, r3
    178a:	4152      	adcs	r2, r2
    178c:	0ac3      	lsrs	r3, r0, #11
    178e:	428b      	cmp	r3, r1
    1790:	d301      	bcc.n	1796 <__aeabi_uidiv+0x76>
    1792:	02cb      	lsls	r3, r1, #11
    1794:	1ac0      	subs	r0, r0, r3
    1796:	4152      	adcs	r2, r2
    1798:	0a83      	lsrs	r3, r0, #10
    179a:	428b      	cmp	r3, r1
    179c:	d301      	bcc.n	17a2 <__aeabi_uidiv+0x82>
    179e:	028b      	lsls	r3, r1, #10
    17a0:	1ac0      	subs	r0, r0, r3
    17a2:	4152      	adcs	r2, r2
    17a4:	0a43      	lsrs	r3, r0, #9
    17a6:	428b      	cmp	r3, r1
    17a8:	d301      	bcc.n	17ae <__aeabi_uidiv+0x8e>
    17aa:	024b      	lsls	r3, r1, #9
    17ac:	1ac0      	subs	r0, r0, r3
    17ae:	4152      	adcs	r2, r2
    17b0:	0a03      	lsrs	r3, r0, #8
    17b2:	428b      	cmp	r3, r1
    17b4:	d301      	bcc.n	17ba <__aeabi_uidiv+0x9a>
    17b6:	020b      	lsls	r3, r1, #8
    17b8:	1ac0      	subs	r0, r0, r3
    17ba:	4152      	adcs	r2, r2
    17bc:	d2cd      	bcs.n	175a <__aeabi_uidiv+0x3a>
    17be:	09c3      	lsrs	r3, r0, #7
    17c0:	428b      	cmp	r3, r1
    17c2:	d301      	bcc.n	17c8 <__aeabi_uidiv+0xa8>
    17c4:	01cb      	lsls	r3, r1, #7
    17c6:	1ac0      	subs	r0, r0, r3
    17c8:	4152      	adcs	r2, r2
    17ca:	0983      	lsrs	r3, r0, #6
    17cc:	428b      	cmp	r3, r1
    17ce:	d301      	bcc.n	17d4 <__aeabi_uidiv+0xb4>
    17d0:	018b      	lsls	r3, r1, #6
    17d2:	1ac0      	subs	r0, r0, r3
    17d4:	4152      	adcs	r2, r2
    17d6:	0943      	lsrs	r3, r0, #5
    17d8:	428b      	cmp	r3, r1
    17da:	d301      	bcc.n	17e0 <__aeabi_uidiv+0xc0>
    17dc:	014b      	lsls	r3, r1, #5
    17de:	1ac0      	subs	r0, r0, r3
    17e0:	4152      	adcs	r2, r2
    17e2:	0903      	lsrs	r3, r0, #4
    17e4:	428b      	cmp	r3, r1
    17e6:	d301      	bcc.n	17ec <__aeabi_uidiv+0xcc>
    17e8:	010b      	lsls	r3, r1, #4
    17ea:	1ac0      	subs	r0, r0, r3
    17ec:	4152      	adcs	r2, r2
    17ee:	08c3      	lsrs	r3, r0, #3
    17f0:	428b      	cmp	r3, r1
    17f2:	d301      	bcc.n	17f8 <__aeabi_uidiv+0xd8>
    17f4:	00cb      	lsls	r3, r1, #3
    17f6:	1ac0      	subs	r0, r0, r3
    17f8:	4152      	adcs	r2, r2
    17fa:	0883      	lsrs	r3, r0, #2
    17fc:	428b      	cmp	r3, r1
    17fe:	d301      	bcc.n	1804 <__aeabi_uidiv+0xe4>
    1800:	008b      	lsls	r3, r1, #2
    1802:	1ac0      	subs	r0, r0, r3
    1804:	4152      	adcs	r2, r2
    1806:	0843      	lsrs	r3, r0, #1
    1808:	428b      	cmp	r3, r1
    180a:	d301      	bcc.n	1810 <__aeabi_uidiv+0xf0>
    180c:	004b      	lsls	r3, r1, #1
    180e:	1ac0      	subs	r0, r0, r3
    1810:	4152      	adcs	r2, r2
    1812:	1a41      	subs	r1, r0, r1
    1814:	d200      	bcs.n	1818 <__aeabi_uidiv+0xf8>
    1816:	4601      	mov	r1, r0
    1818:	4152      	adcs	r2, r2
    181a:	4610      	mov	r0, r2
    181c:	4770      	bx	lr
    181e:	e7ff      	b.n	1820 <__aeabi_uidiv+0x100>
    1820:	b501      	push	{r0, lr}
    1822:	2000      	movs	r0, #0
    1824:	f000 f80c 	bl	1840 <__aeabi_idiv0>
    1828:	bd02      	pop	{r1, pc}
    182a:	46c0      	nop			; (mov r8, r8)

0000182c <__aeabi_uidivmod>:
    182c:	2900      	cmp	r1, #0
    182e:	d0f7      	beq.n	1820 <__aeabi_uidiv+0x100>
    1830:	b503      	push	{r0, r1, lr}
    1832:	f7ff ff75 	bl	1720 <__aeabi_uidiv>
    1836:	bc0e      	pop	{r1, r2, r3}
    1838:	4342      	muls	r2, r0
    183a:	1a89      	subs	r1, r1, r2
    183c:	4718      	bx	r3
    183e:	46c0      	nop			; (mov r8, r8)

00001840 <__aeabi_idiv0>:
    1840:	4770      	bx	lr
    1842:	46c0      	nop			; (mov r8, r8)

00001844 <__aeabi_lmul>:
    1844:	b5f0      	push	{r4, r5, r6, r7, lr}
    1846:	464f      	mov	r7, r9
    1848:	4646      	mov	r6, r8
    184a:	0405      	lsls	r5, r0, #16
    184c:	0c2d      	lsrs	r5, r5, #16
    184e:	1c2c      	adds	r4, r5, #0
    1850:	b4c0      	push	{r6, r7}
    1852:	0417      	lsls	r7, r2, #16
    1854:	0c16      	lsrs	r6, r2, #16
    1856:	0c3f      	lsrs	r7, r7, #16
    1858:	4699      	mov	r9, r3
    185a:	0c03      	lsrs	r3, r0, #16
    185c:	437c      	muls	r4, r7
    185e:	4375      	muls	r5, r6
    1860:	435f      	muls	r7, r3
    1862:	4373      	muls	r3, r6
    1864:	197d      	adds	r5, r7, r5
    1866:	0c26      	lsrs	r6, r4, #16
    1868:	19ad      	adds	r5, r5, r6
    186a:	469c      	mov	ip, r3
    186c:	42af      	cmp	r7, r5
    186e:	d903      	bls.n	1878 <__aeabi_lmul+0x34>
    1870:	2380      	movs	r3, #128	; 0x80
    1872:	025b      	lsls	r3, r3, #9
    1874:	4698      	mov	r8, r3
    1876:	44c4      	add	ip, r8
    1878:	464b      	mov	r3, r9
    187a:	4351      	muls	r1, r2
    187c:	4343      	muls	r3, r0
    187e:	0424      	lsls	r4, r4, #16
    1880:	0c2e      	lsrs	r6, r5, #16
    1882:	0c24      	lsrs	r4, r4, #16
    1884:	042d      	lsls	r5, r5, #16
    1886:	4466      	add	r6, ip
    1888:	192c      	adds	r4, r5, r4
    188a:	1859      	adds	r1, r3, r1
    188c:	1989      	adds	r1, r1, r6
    188e:	1c20      	adds	r0, r4, #0
    1890:	bc0c      	pop	{r2, r3}
    1892:	4690      	mov	r8, r2
    1894:	4699      	mov	r9, r3
    1896:	bdf0      	pop	{r4, r5, r6, r7, pc}

00001898 <__libc_init_array>:
    1898:	4b0e      	ldr	r3, [pc, #56]	; (18d4 <__libc_init_array+0x3c>)
    189a:	b570      	push	{r4, r5, r6, lr}
    189c:	2500      	movs	r5, #0
    189e:	1c1e      	adds	r6, r3, #0
    18a0:	4c0d      	ldr	r4, [pc, #52]	; (18d8 <__libc_init_array+0x40>)
    18a2:	1ae4      	subs	r4, r4, r3
    18a4:	10a4      	asrs	r4, r4, #2
    18a6:	42a5      	cmp	r5, r4
    18a8:	d004      	beq.n	18b4 <__libc_init_array+0x1c>
    18aa:	00ab      	lsls	r3, r5, #2
    18ac:	58f3      	ldr	r3, [r6, r3]
    18ae:	4798      	blx	r3
    18b0:	3501      	adds	r5, #1
    18b2:	e7f8      	b.n	18a6 <__libc_init_array+0xe>
    18b4:	f001 f8a0 	bl	29f8 <_init>
    18b8:	4b08      	ldr	r3, [pc, #32]	; (18dc <__libc_init_array+0x44>)
    18ba:	2500      	movs	r5, #0
    18bc:	1c1e      	adds	r6, r3, #0
    18be:	4c08      	ldr	r4, [pc, #32]	; (18e0 <__libc_init_array+0x48>)
    18c0:	1ae4      	subs	r4, r4, r3
    18c2:	10a4      	asrs	r4, r4, #2
    18c4:	42a5      	cmp	r5, r4
    18c6:	d004      	beq.n	18d2 <__libc_init_array+0x3a>
    18c8:	00ab      	lsls	r3, r5, #2
    18ca:	58f3      	ldr	r3, [r6, r3]
    18cc:	4798      	blx	r3
    18ce:	3501      	adds	r5, #1
    18d0:	e7f8      	b.n	18c4 <__libc_init_array+0x2c>
    18d2:	bd70      	pop	{r4, r5, r6, pc}
    18d4:	00002a04 	.word	0x00002a04
    18d8:	00002a04 	.word	0x00002a04
    18dc:	00002a04 	.word	0x00002a04
    18e0:	00002a08 	.word	0x00002a08

000018e4 <memcpy>:
    18e4:	2300      	movs	r3, #0
    18e6:	b510      	push	{r4, lr}
    18e8:	4293      	cmp	r3, r2
    18ea:	d003      	beq.n	18f4 <memcpy+0x10>
    18ec:	5ccc      	ldrb	r4, [r1, r3]
    18ee:	54c4      	strb	r4, [r0, r3]
    18f0:	3301      	adds	r3, #1
    18f2:	e7f9      	b.n	18e8 <memcpy+0x4>
    18f4:	bd10      	pop	{r4, pc}

000018f6 <memset>:
    18f6:	1c03      	adds	r3, r0, #0
    18f8:	1882      	adds	r2, r0, r2
    18fa:	4293      	cmp	r3, r2
    18fc:	d002      	beq.n	1904 <memset+0xe>
    18fe:	7019      	strb	r1, [r3, #0]
    1900:	3301      	adds	r3, #1
    1902:	e7fa      	b.n	18fa <memset+0x4>
    1904:	4770      	bx	lr
	...

00001908 <iprintf>:
    1908:	b40f      	push	{r0, r1, r2, r3}
    190a:	4b0b      	ldr	r3, [pc, #44]	; (1938 <iprintf+0x30>)
    190c:	b513      	push	{r0, r1, r4, lr}
    190e:	681c      	ldr	r4, [r3, #0]
    1910:	2c00      	cmp	r4, #0
    1912:	d005      	beq.n	1920 <iprintf+0x18>
    1914:	69a3      	ldr	r3, [r4, #24]
    1916:	2b00      	cmp	r3, #0
    1918:	d102      	bne.n	1920 <iprintf+0x18>
    191a:	1c20      	adds	r0, r4, #0
    191c:	f000 f9aa 	bl	1c74 <__sinit>
    1920:	ab05      	add	r3, sp, #20
    1922:	1c20      	adds	r0, r4, #0
    1924:	68a1      	ldr	r1, [r4, #8]
    1926:	9a04      	ldr	r2, [sp, #16]
    1928:	9301      	str	r3, [sp, #4]
    192a:	f000 fb05 	bl	1f38 <_vfiprintf_r>
    192e:	bc16      	pop	{r1, r2, r4}
    1930:	bc08      	pop	{r3}
    1932:	b004      	add	sp, #16
    1934:	4718      	bx	r3
    1936:	46c0      	nop			; (mov r8, r8)
    1938:	20000064 	.word	0x20000064

0000193c <putchar>:
    193c:	b538      	push	{r3, r4, r5, lr}
    193e:	4b08      	ldr	r3, [pc, #32]	; (1960 <putchar+0x24>)
    1940:	1c05      	adds	r5, r0, #0
    1942:	681c      	ldr	r4, [r3, #0]
    1944:	2c00      	cmp	r4, #0
    1946:	d005      	beq.n	1954 <putchar+0x18>
    1948:	69a3      	ldr	r3, [r4, #24]
    194a:	2b00      	cmp	r3, #0
    194c:	d102      	bne.n	1954 <putchar+0x18>
    194e:	1c20      	adds	r0, r4, #0
    1950:	f000 f990 	bl	1c74 <__sinit>
    1954:	1c29      	adds	r1, r5, #0
    1956:	1c20      	adds	r0, r4, #0
    1958:	68a2      	ldr	r2, [r4, #8]
    195a:	f000 fd83 	bl	2464 <_putc_r>
    195e:	bd38      	pop	{r3, r4, r5, pc}
    1960:	20000064 	.word	0x20000064

00001964 <setbuf>:
    1964:	b508      	push	{r3, lr}
    1966:	424a      	negs	r2, r1
    1968:	414a      	adcs	r2, r1
    196a:	2380      	movs	r3, #128	; 0x80
    196c:	0052      	lsls	r2, r2, #1
    196e:	00db      	lsls	r3, r3, #3
    1970:	f000 f802 	bl	1978 <setvbuf>
    1974:	bd08      	pop	{r3, pc}
	...

00001978 <setvbuf>:
    1978:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    197a:	1c1e      	adds	r6, r3, #0
    197c:	4b3c      	ldr	r3, [pc, #240]	; (1a70 <setvbuf+0xf8>)
    197e:	1c04      	adds	r4, r0, #0
    1980:	681d      	ldr	r5, [r3, #0]
    1982:	1c0f      	adds	r7, r1, #0
    1984:	9201      	str	r2, [sp, #4]
    1986:	2d00      	cmp	r5, #0
    1988:	d005      	beq.n	1996 <setvbuf+0x1e>
    198a:	69ab      	ldr	r3, [r5, #24]
    198c:	2b00      	cmp	r3, #0
    198e:	d102      	bne.n	1996 <setvbuf+0x1e>
    1990:	1c28      	adds	r0, r5, #0
    1992:	f000 f96f 	bl	1c74 <__sinit>
    1996:	4b37      	ldr	r3, [pc, #220]	; (1a74 <setvbuf+0xfc>)
    1998:	429c      	cmp	r4, r3
    199a:	d101      	bne.n	19a0 <setvbuf+0x28>
    199c:	686c      	ldr	r4, [r5, #4]
    199e:	e008      	b.n	19b2 <setvbuf+0x3a>
    19a0:	4b35      	ldr	r3, [pc, #212]	; (1a78 <setvbuf+0x100>)
    19a2:	429c      	cmp	r4, r3
    19a4:	d101      	bne.n	19aa <setvbuf+0x32>
    19a6:	68ac      	ldr	r4, [r5, #8]
    19a8:	e003      	b.n	19b2 <setvbuf+0x3a>
    19aa:	4b34      	ldr	r3, [pc, #208]	; (1a7c <setvbuf+0x104>)
    19ac:	429c      	cmp	r4, r3
    19ae:	d100      	bne.n	19b2 <setvbuf+0x3a>
    19b0:	68ec      	ldr	r4, [r5, #12]
    19b2:	9b01      	ldr	r3, [sp, #4]
    19b4:	2b02      	cmp	r3, #2
    19b6:	d858      	bhi.n	1a6a <setvbuf+0xf2>
    19b8:	2e00      	cmp	r6, #0
    19ba:	db56      	blt.n	1a6a <setvbuf+0xf2>
    19bc:	1c28      	adds	r0, r5, #0
    19be:	1c21      	adds	r1, r4, #0
    19c0:	f000 f8ea 	bl	1b98 <_fflush_r>
    19c4:	2300      	movs	r3, #0
    19c6:	6063      	str	r3, [r4, #4]
    19c8:	61a3      	str	r3, [r4, #24]
    19ca:	89a3      	ldrh	r3, [r4, #12]
    19cc:	061b      	lsls	r3, r3, #24
    19ce:	d503      	bpl.n	19d8 <setvbuf+0x60>
    19d0:	1c28      	adds	r0, r5, #0
    19d2:	6921      	ldr	r1, [r4, #16]
    19d4:	f000 f9ea 	bl	1dac <_free_r>
    19d8:	2283      	movs	r2, #131	; 0x83
    19da:	89a3      	ldrh	r3, [r4, #12]
    19dc:	4393      	bics	r3, r2
    19de:	81a3      	strh	r3, [r4, #12]
    19e0:	9b01      	ldr	r3, [sp, #4]
    19e2:	2b02      	cmp	r3, #2
    19e4:	d013      	beq.n	1a0e <setvbuf+0x96>
    19e6:	2f00      	cmp	r7, #0
    19e8:	d125      	bne.n	1a36 <setvbuf+0xbe>
    19ea:	2e00      	cmp	r6, #0
    19ec:	d101      	bne.n	19f2 <setvbuf+0x7a>
    19ee:	2680      	movs	r6, #128	; 0x80
    19f0:	00f6      	lsls	r6, r6, #3
    19f2:	1c30      	adds	r0, r6, #0
    19f4:	f000 f9d0 	bl	1d98 <malloc>
    19f8:	1e07      	subs	r7, r0, #0
    19fa:	d118      	bne.n	1a2e <setvbuf+0xb6>
    19fc:	2080      	movs	r0, #128	; 0x80
    19fe:	00c0      	lsls	r0, r0, #3
    1a00:	f000 f9ca 	bl	1d98 <malloc>
    1a04:	1e07      	subs	r7, r0, #0
    1a06:	d110      	bne.n	1a2a <setvbuf+0xb2>
    1a08:	2001      	movs	r0, #1
    1a0a:	4240      	negs	r0, r0
    1a0c:	e000      	b.n	1a10 <setvbuf+0x98>
    1a0e:	2000      	movs	r0, #0
    1a10:	2202      	movs	r2, #2
    1a12:	89a3      	ldrh	r3, [r4, #12]
    1a14:	4313      	orrs	r3, r2
    1a16:	81a3      	strh	r3, [r4, #12]
    1a18:	2300      	movs	r3, #0
    1a1a:	60a3      	str	r3, [r4, #8]
    1a1c:	1c23      	adds	r3, r4, #0
    1a1e:	3347      	adds	r3, #71	; 0x47
    1a20:	6023      	str	r3, [r4, #0]
    1a22:	6123      	str	r3, [r4, #16]
    1a24:	2301      	movs	r3, #1
    1a26:	6163      	str	r3, [r4, #20]
    1a28:	e021      	b.n	1a6e <setvbuf+0xf6>
    1a2a:	2680      	movs	r6, #128	; 0x80
    1a2c:	00f6      	lsls	r6, r6, #3
    1a2e:	2280      	movs	r2, #128	; 0x80
    1a30:	89a3      	ldrh	r3, [r4, #12]
    1a32:	4313      	orrs	r3, r2
    1a34:	81a3      	strh	r3, [r4, #12]
    1a36:	9b01      	ldr	r3, [sp, #4]
    1a38:	2b01      	cmp	r3, #1
    1a3a:	d105      	bne.n	1a48 <setvbuf+0xd0>
    1a3c:	89a3      	ldrh	r3, [r4, #12]
    1a3e:	9a01      	ldr	r2, [sp, #4]
    1a40:	431a      	orrs	r2, r3
    1a42:	4273      	negs	r3, r6
    1a44:	81a2      	strh	r2, [r4, #12]
    1a46:	61a3      	str	r3, [r4, #24]
    1a48:	4b0d      	ldr	r3, [pc, #52]	; (1a80 <setvbuf+0x108>)
    1a4a:	2000      	movs	r0, #0
    1a4c:	62ab      	str	r3, [r5, #40]	; 0x28
    1a4e:	89a2      	ldrh	r2, [r4, #12]
    1a50:	6027      	str	r7, [r4, #0]
    1a52:	6127      	str	r7, [r4, #16]
    1a54:	6166      	str	r6, [r4, #20]
    1a56:	0713      	lsls	r3, r2, #28
    1a58:	d509      	bpl.n	1a6e <setvbuf+0xf6>
    1a5a:	2303      	movs	r3, #3
    1a5c:	401a      	ands	r2, r3
    1a5e:	4253      	negs	r3, r2
    1a60:	4153      	adcs	r3, r2
    1a62:	425b      	negs	r3, r3
    1a64:	401e      	ands	r6, r3
    1a66:	60a6      	str	r6, [r4, #8]
    1a68:	e001      	b.n	1a6e <setvbuf+0xf6>
    1a6a:	2001      	movs	r0, #1
    1a6c:	4240      	negs	r0, r0
    1a6e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    1a70:	20000064 	.word	0x20000064
    1a74:	00002964 	.word	0x00002964
    1a78:	00002984 	.word	0x00002984
    1a7c:	000029a4 	.word	0x000029a4
    1a80:	00001bf1 	.word	0x00001bf1

00001a84 <__sflush_r>:
    1a84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1a86:	898a      	ldrh	r2, [r1, #12]
    1a88:	1c05      	adds	r5, r0, #0
    1a8a:	1c0c      	adds	r4, r1, #0
    1a8c:	0713      	lsls	r3, r2, #28
    1a8e:	d45e      	bmi.n	1b4e <__sflush_r+0xca>
    1a90:	684b      	ldr	r3, [r1, #4]
    1a92:	2b00      	cmp	r3, #0
    1a94:	dc02      	bgt.n	1a9c <__sflush_r+0x18>
    1a96:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    1a98:	2b00      	cmp	r3, #0
    1a9a:	dd1a      	ble.n	1ad2 <__sflush_r+0x4e>
    1a9c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    1a9e:	2f00      	cmp	r7, #0
    1aa0:	d017      	beq.n	1ad2 <__sflush_r+0x4e>
    1aa2:	2300      	movs	r3, #0
    1aa4:	682e      	ldr	r6, [r5, #0]
    1aa6:	602b      	str	r3, [r5, #0]
    1aa8:	2380      	movs	r3, #128	; 0x80
    1aaa:	015b      	lsls	r3, r3, #5
    1aac:	401a      	ands	r2, r3
    1aae:	d001      	beq.n	1ab4 <__sflush_r+0x30>
    1ab0:	6d62      	ldr	r2, [r4, #84]	; 0x54
    1ab2:	e015      	b.n	1ae0 <__sflush_r+0x5c>
    1ab4:	1c28      	adds	r0, r5, #0
    1ab6:	6a21      	ldr	r1, [r4, #32]
    1ab8:	2301      	movs	r3, #1
    1aba:	47b8      	blx	r7
    1abc:	1c02      	adds	r2, r0, #0
    1abe:	1c43      	adds	r3, r0, #1
    1ac0:	d10e      	bne.n	1ae0 <__sflush_r+0x5c>
    1ac2:	682b      	ldr	r3, [r5, #0]
    1ac4:	2b00      	cmp	r3, #0
    1ac6:	d00b      	beq.n	1ae0 <__sflush_r+0x5c>
    1ac8:	2b1d      	cmp	r3, #29
    1aca:	d001      	beq.n	1ad0 <__sflush_r+0x4c>
    1acc:	2b16      	cmp	r3, #22
    1ace:	d102      	bne.n	1ad6 <__sflush_r+0x52>
    1ad0:	602e      	str	r6, [r5, #0]
    1ad2:	2000      	movs	r0, #0
    1ad4:	e05e      	b.n	1b94 <__sflush_r+0x110>
    1ad6:	2140      	movs	r1, #64	; 0x40
    1ad8:	89a3      	ldrh	r3, [r4, #12]
    1ada:	430b      	orrs	r3, r1
    1adc:	81a3      	strh	r3, [r4, #12]
    1ade:	e059      	b.n	1b94 <__sflush_r+0x110>
    1ae0:	89a3      	ldrh	r3, [r4, #12]
    1ae2:	075b      	lsls	r3, r3, #29
    1ae4:	d506      	bpl.n	1af4 <__sflush_r+0x70>
    1ae6:	6863      	ldr	r3, [r4, #4]
    1ae8:	1ad2      	subs	r2, r2, r3
    1aea:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1aec:	2b00      	cmp	r3, #0
    1aee:	d001      	beq.n	1af4 <__sflush_r+0x70>
    1af0:	6c23      	ldr	r3, [r4, #64]	; 0x40
    1af2:	1ad2      	subs	r2, r2, r3
    1af4:	2300      	movs	r3, #0
    1af6:	1c28      	adds	r0, r5, #0
    1af8:	6a21      	ldr	r1, [r4, #32]
    1afa:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    1afc:	47b8      	blx	r7
    1afe:	89a3      	ldrh	r3, [r4, #12]
    1b00:	1c42      	adds	r2, r0, #1
    1b02:	d106      	bne.n	1b12 <__sflush_r+0x8e>
    1b04:	682a      	ldr	r2, [r5, #0]
    1b06:	2a00      	cmp	r2, #0
    1b08:	d003      	beq.n	1b12 <__sflush_r+0x8e>
    1b0a:	2a1d      	cmp	r2, #29
    1b0c:	d001      	beq.n	1b12 <__sflush_r+0x8e>
    1b0e:	2a16      	cmp	r2, #22
    1b10:	d119      	bne.n	1b46 <__sflush_r+0xc2>
    1b12:	2200      	movs	r2, #0
    1b14:	6062      	str	r2, [r4, #4]
    1b16:	6922      	ldr	r2, [r4, #16]
    1b18:	6022      	str	r2, [r4, #0]
    1b1a:	04db      	lsls	r3, r3, #19
    1b1c:	d505      	bpl.n	1b2a <__sflush_r+0xa6>
    1b1e:	1c43      	adds	r3, r0, #1
    1b20:	d102      	bne.n	1b28 <__sflush_r+0xa4>
    1b22:	682b      	ldr	r3, [r5, #0]
    1b24:	2b00      	cmp	r3, #0
    1b26:	d100      	bne.n	1b2a <__sflush_r+0xa6>
    1b28:	6560      	str	r0, [r4, #84]	; 0x54
    1b2a:	6b61      	ldr	r1, [r4, #52]	; 0x34
    1b2c:	602e      	str	r6, [r5, #0]
    1b2e:	2900      	cmp	r1, #0
    1b30:	d0cf      	beq.n	1ad2 <__sflush_r+0x4e>
    1b32:	1c23      	adds	r3, r4, #0
    1b34:	3344      	adds	r3, #68	; 0x44
    1b36:	4299      	cmp	r1, r3
    1b38:	d002      	beq.n	1b40 <__sflush_r+0xbc>
    1b3a:	1c28      	adds	r0, r5, #0
    1b3c:	f000 f936 	bl	1dac <_free_r>
    1b40:	2000      	movs	r0, #0
    1b42:	6360      	str	r0, [r4, #52]	; 0x34
    1b44:	e026      	b.n	1b94 <__sflush_r+0x110>
    1b46:	2240      	movs	r2, #64	; 0x40
    1b48:	4313      	orrs	r3, r2
    1b4a:	81a3      	strh	r3, [r4, #12]
    1b4c:	e022      	b.n	1b94 <__sflush_r+0x110>
    1b4e:	690f      	ldr	r7, [r1, #16]
    1b50:	2f00      	cmp	r7, #0
    1b52:	d0be      	beq.n	1ad2 <__sflush_r+0x4e>
    1b54:	680b      	ldr	r3, [r1, #0]
    1b56:	600f      	str	r7, [r1, #0]
    1b58:	1bdb      	subs	r3, r3, r7
    1b5a:	9301      	str	r3, [sp, #4]
    1b5c:	2300      	movs	r3, #0
    1b5e:	0792      	lsls	r2, r2, #30
    1b60:	d100      	bne.n	1b64 <__sflush_r+0xe0>
    1b62:	694b      	ldr	r3, [r1, #20]
    1b64:	60a3      	str	r3, [r4, #8]
    1b66:	9b01      	ldr	r3, [sp, #4]
    1b68:	2b00      	cmp	r3, #0
    1b6a:	ddb2      	ble.n	1ad2 <__sflush_r+0x4e>
    1b6c:	1c28      	adds	r0, r5, #0
    1b6e:	6a21      	ldr	r1, [r4, #32]
    1b70:	1c3a      	adds	r2, r7, #0
    1b72:	9b01      	ldr	r3, [sp, #4]
    1b74:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    1b76:	47b0      	blx	r6
    1b78:	2800      	cmp	r0, #0
    1b7a:	dc06      	bgt.n	1b8a <__sflush_r+0x106>
    1b7c:	2240      	movs	r2, #64	; 0x40
    1b7e:	2001      	movs	r0, #1
    1b80:	89a3      	ldrh	r3, [r4, #12]
    1b82:	4240      	negs	r0, r0
    1b84:	4313      	orrs	r3, r2
    1b86:	81a3      	strh	r3, [r4, #12]
    1b88:	e004      	b.n	1b94 <__sflush_r+0x110>
    1b8a:	9b01      	ldr	r3, [sp, #4]
    1b8c:	183f      	adds	r7, r7, r0
    1b8e:	1a1b      	subs	r3, r3, r0
    1b90:	9301      	str	r3, [sp, #4]
    1b92:	e7e8      	b.n	1b66 <__sflush_r+0xe2>
    1b94:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

00001b98 <_fflush_r>:
    1b98:	b538      	push	{r3, r4, r5, lr}
    1b9a:	690b      	ldr	r3, [r1, #16]
    1b9c:	1c05      	adds	r5, r0, #0
    1b9e:	1c0c      	adds	r4, r1, #0
    1ba0:	2b00      	cmp	r3, #0
    1ba2:	d101      	bne.n	1ba8 <_fflush_r+0x10>
    1ba4:	2000      	movs	r0, #0
    1ba6:	e01c      	b.n	1be2 <_fflush_r+0x4a>
    1ba8:	2800      	cmp	r0, #0
    1baa:	d004      	beq.n	1bb6 <_fflush_r+0x1e>
    1bac:	6983      	ldr	r3, [r0, #24]
    1bae:	2b00      	cmp	r3, #0
    1bb0:	d101      	bne.n	1bb6 <_fflush_r+0x1e>
    1bb2:	f000 f85f 	bl	1c74 <__sinit>
    1bb6:	4b0b      	ldr	r3, [pc, #44]	; (1be4 <_fflush_r+0x4c>)
    1bb8:	429c      	cmp	r4, r3
    1bba:	d101      	bne.n	1bc0 <_fflush_r+0x28>
    1bbc:	686c      	ldr	r4, [r5, #4]
    1bbe:	e008      	b.n	1bd2 <_fflush_r+0x3a>
    1bc0:	4b09      	ldr	r3, [pc, #36]	; (1be8 <_fflush_r+0x50>)
    1bc2:	429c      	cmp	r4, r3
    1bc4:	d101      	bne.n	1bca <_fflush_r+0x32>
    1bc6:	68ac      	ldr	r4, [r5, #8]
    1bc8:	e003      	b.n	1bd2 <_fflush_r+0x3a>
    1bca:	4b08      	ldr	r3, [pc, #32]	; (1bec <_fflush_r+0x54>)
    1bcc:	429c      	cmp	r4, r3
    1bce:	d100      	bne.n	1bd2 <_fflush_r+0x3a>
    1bd0:	68ec      	ldr	r4, [r5, #12]
    1bd2:	220c      	movs	r2, #12
    1bd4:	5ea3      	ldrsh	r3, [r4, r2]
    1bd6:	2b00      	cmp	r3, #0
    1bd8:	d0e4      	beq.n	1ba4 <_fflush_r+0xc>
    1bda:	1c28      	adds	r0, r5, #0
    1bdc:	1c21      	adds	r1, r4, #0
    1bde:	f7ff ff51 	bl	1a84 <__sflush_r>
    1be2:	bd38      	pop	{r3, r4, r5, pc}
    1be4:	00002964 	.word	0x00002964
    1be8:	00002984 	.word	0x00002984
    1bec:	000029a4 	.word	0x000029a4

00001bf0 <_cleanup_r>:
    1bf0:	b508      	push	{r3, lr}
    1bf2:	4902      	ldr	r1, [pc, #8]	; (1bfc <_cleanup_r+0xc>)
    1bf4:	f000 f8ae 	bl	1d54 <_fwalk_reent>
    1bf8:	bd08      	pop	{r3, pc}
    1bfa:	46c0      	nop			; (mov r8, r8)
    1bfc:	00001b99 	.word	0x00001b99

00001c00 <std.isra.0>:
    1c00:	2300      	movs	r3, #0
    1c02:	b510      	push	{r4, lr}
    1c04:	1c04      	adds	r4, r0, #0
    1c06:	6003      	str	r3, [r0, #0]
    1c08:	6043      	str	r3, [r0, #4]
    1c0a:	6083      	str	r3, [r0, #8]
    1c0c:	8181      	strh	r1, [r0, #12]
    1c0e:	6643      	str	r3, [r0, #100]	; 0x64
    1c10:	81c2      	strh	r2, [r0, #14]
    1c12:	6103      	str	r3, [r0, #16]
    1c14:	6143      	str	r3, [r0, #20]
    1c16:	6183      	str	r3, [r0, #24]
    1c18:	1c19      	adds	r1, r3, #0
    1c1a:	2208      	movs	r2, #8
    1c1c:	305c      	adds	r0, #92	; 0x5c
    1c1e:	f7ff fe6a 	bl	18f6 <memset>
    1c22:	4b05      	ldr	r3, [pc, #20]	; (1c38 <std.isra.0+0x38>)
    1c24:	6224      	str	r4, [r4, #32]
    1c26:	6263      	str	r3, [r4, #36]	; 0x24
    1c28:	4b04      	ldr	r3, [pc, #16]	; (1c3c <std.isra.0+0x3c>)
    1c2a:	62a3      	str	r3, [r4, #40]	; 0x28
    1c2c:	4b04      	ldr	r3, [pc, #16]	; (1c40 <std.isra.0+0x40>)
    1c2e:	62e3      	str	r3, [r4, #44]	; 0x2c
    1c30:	4b04      	ldr	r3, [pc, #16]	; (1c44 <std.isra.0+0x44>)
    1c32:	6323      	str	r3, [r4, #48]	; 0x30
    1c34:	bd10      	pop	{r4, pc}
    1c36:	46c0      	nop			; (mov r8, r8)
    1c38:	00002501 	.word	0x00002501
    1c3c:	00002529 	.word	0x00002529
    1c40:	00002561 	.word	0x00002561
    1c44:	0000258d 	.word	0x0000258d

00001c48 <__sfmoreglue>:
    1c48:	b570      	push	{r4, r5, r6, lr}
    1c4a:	2568      	movs	r5, #104	; 0x68
    1c4c:	1e4b      	subs	r3, r1, #1
    1c4e:	435d      	muls	r5, r3
    1c50:	1c0e      	adds	r6, r1, #0
    1c52:	1c29      	adds	r1, r5, #0
    1c54:	3174      	adds	r1, #116	; 0x74
    1c56:	f000 f8ef 	bl	1e38 <_malloc_r>
    1c5a:	1e04      	subs	r4, r0, #0
    1c5c:	d008      	beq.n	1c70 <__sfmoreglue+0x28>
    1c5e:	2100      	movs	r1, #0
    1c60:	1c2a      	adds	r2, r5, #0
    1c62:	6001      	str	r1, [r0, #0]
    1c64:	6046      	str	r6, [r0, #4]
    1c66:	300c      	adds	r0, #12
    1c68:	60a0      	str	r0, [r4, #8]
    1c6a:	3268      	adds	r2, #104	; 0x68
    1c6c:	f7ff fe43 	bl	18f6 <memset>
    1c70:	1c20      	adds	r0, r4, #0
    1c72:	bd70      	pop	{r4, r5, r6, pc}

00001c74 <__sinit>:
    1c74:	6983      	ldr	r3, [r0, #24]
    1c76:	b513      	push	{r0, r1, r4, lr}
    1c78:	2b00      	cmp	r3, #0
    1c7a:	d128      	bne.n	1cce <__sinit+0x5a>
    1c7c:	6483      	str	r3, [r0, #72]	; 0x48
    1c7e:	64c3      	str	r3, [r0, #76]	; 0x4c
    1c80:	6503      	str	r3, [r0, #80]	; 0x50
    1c82:	4b13      	ldr	r3, [pc, #76]	; (1cd0 <__sinit+0x5c>)
    1c84:	4a13      	ldr	r2, [pc, #76]	; (1cd4 <__sinit+0x60>)
    1c86:	681b      	ldr	r3, [r3, #0]
    1c88:	6282      	str	r2, [r0, #40]	; 0x28
    1c8a:	9301      	str	r3, [sp, #4]
    1c8c:	4298      	cmp	r0, r3
    1c8e:	d101      	bne.n	1c94 <__sinit+0x20>
    1c90:	2301      	movs	r3, #1
    1c92:	6183      	str	r3, [r0, #24]
    1c94:	1c04      	adds	r4, r0, #0
    1c96:	f000 f81f 	bl	1cd8 <__sfp>
    1c9a:	6060      	str	r0, [r4, #4]
    1c9c:	1c20      	adds	r0, r4, #0
    1c9e:	f000 f81b 	bl	1cd8 <__sfp>
    1ca2:	60a0      	str	r0, [r4, #8]
    1ca4:	1c20      	adds	r0, r4, #0
    1ca6:	f000 f817 	bl	1cd8 <__sfp>
    1caa:	2104      	movs	r1, #4
    1cac:	60e0      	str	r0, [r4, #12]
    1cae:	2200      	movs	r2, #0
    1cb0:	6860      	ldr	r0, [r4, #4]
    1cb2:	f7ff ffa5 	bl	1c00 <std.isra.0>
    1cb6:	68a0      	ldr	r0, [r4, #8]
    1cb8:	2109      	movs	r1, #9
    1cba:	2201      	movs	r2, #1
    1cbc:	f7ff ffa0 	bl	1c00 <std.isra.0>
    1cc0:	68e0      	ldr	r0, [r4, #12]
    1cc2:	2112      	movs	r1, #18
    1cc4:	2202      	movs	r2, #2
    1cc6:	f7ff ff9b 	bl	1c00 <std.isra.0>
    1cca:	2301      	movs	r3, #1
    1ccc:	61a3      	str	r3, [r4, #24]
    1cce:	bd13      	pop	{r0, r1, r4, pc}
    1cd0:	00002960 	.word	0x00002960
    1cd4:	00001bf1 	.word	0x00001bf1

00001cd8 <__sfp>:
    1cd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1cda:	4b1d      	ldr	r3, [pc, #116]	; (1d50 <__sfp+0x78>)
    1cdc:	1c06      	adds	r6, r0, #0
    1cde:	681d      	ldr	r5, [r3, #0]
    1ce0:	69ab      	ldr	r3, [r5, #24]
    1ce2:	2b00      	cmp	r3, #0
    1ce4:	d102      	bne.n	1cec <__sfp+0x14>
    1ce6:	1c28      	adds	r0, r5, #0
    1ce8:	f7ff ffc4 	bl	1c74 <__sinit>
    1cec:	3548      	adds	r5, #72	; 0x48
    1cee:	68ac      	ldr	r4, [r5, #8]
    1cf0:	686b      	ldr	r3, [r5, #4]
    1cf2:	3b01      	subs	r3, #1
    1cf4:	d405      	bmi.n	1d02 <__sfp+0x2a>
    1cf6:	220c      	movs	r2, #12
    1cf8:	5ea7      	ldrsh	r7, [r4, r2]
    1cfa:	2f00      	cmp	r7, #0
    1cfc:	d010      	beq.n	1d20 <__sfp+0x48>
    1cfe:	3468      	adds	r4, #104	; 0x68
    1d00:	e7f7      	b.n	1cf2 <__sfp+0x1a>
    1d02:	682b      	ldr	r3, [r5, #0]
    1d04:	2b00      	cmp	r3, #0
    1d06:	d106      	bne.n	1d16 <__sfp+0x3e>
    1d08:	1c30      	adds	r0, r6, #0
    1d0a:	2104      	movs	r1, #4
    1d0c:	f7ff ff9c 	bl	1c48 <__sfmoreglue>
    1d10:	6028      	str	r0, [r5, #0]
    1d12:	2800      	cmp	r0, #0
    1d14:	d001      	beq.n	1d1a <__sfp+0x42>
    1d16:	682d      	ldr	r5, [r5, #0]
    1d18:	e7e9      	b.n	1cee <__sfp+0x16>
    1d1a:	230c      	movs	r3, #12
    1d1c:	6033      	str	r3, [r6, #0]
    1d1e:	e016      	b.n	1d4e <__sfp+0x76>
    1d20:	2301      	movs	r3, #1
    1d22:	1c20      	adds	r0, r4, #0
    1d24:	425b      	negs	r3, r3
    1d26:	81e3      	strh	r3, [r4, #14]
    1d28:	3302      	adds	r3, #2
    1d2a:	81a3      	strh	r3, [r4, #12]
    1d2c:	6667      	str	r7, [r4, #100]	; 0x64
    1d2e:	6027      	str	r7, [r4, #0]
    1d30:	60a7      	str	r7, [r4, #8]
    1d32:	6067      	str	r7, [r4, #4]
    1d34:	6127      	str	r7, [r4, #16]
    1d36:	6167      	str	r7, [r4, #20]
    1d38:	61a7      	str	r7, [r4, #24]
    1d3a:	305c      	adds	r0, #92	; 0x5c
    1d3c:	1c39      	adds	r1, r7, #0
    1d3e:	2208      	movs	r2, #8
    1d40:	f7ff fdd9 	bl	18f6 <memset>
    1d44:	1c20      	adds	r0, r4, #0
    1d46:	6367      	str	r7, [r4, #52]	; 0x34
    1d48:	63a7      	str	r7, [r4, #56]	; 0x38
    1d4a:	64a7      	str	r7, [r4, #72]	; 0x48
    1d4c:	64e7      	str	r7, [r4, #76]	; 0x4c
    1d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1d50:	00002960 	.word	0x00002960

00001d54 <_fwalk_reent>:
    1d54:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1d56:	1c04      	adds	r4, r0, #0
    1d58:	1c07      	adds	r7, r0, #0
    1d5a:	2600      	movs	r6, #0
    1d5c:	9101      	str	r1, [sp, #4]
    1d5e:	3448      	adds	r4, #72	; 0x48
    1d60:	2c00      	cmp	r4, #0
    1d62:	d016      	beq.n	1d92 <_fwalk_reent+0x3e>
    1d64:	6863      	ldr	r3, [r4, #4]
    1d66:	68a5      	ldr	r5, [r4, #8]
    1d68:	9300      	str	r3, [sp, #0]
    1d6a:	9b00      	ldr	r3, [sp, #0]
    1d6c:	3b01      	subs	r3, #1
    1d6e:	9300      	str	r3, [sp, #0]
    1d70:	d40d      	bmi.n	1d8e <_fwalk_reent+0x3a>
    1d72:	89ab      	ldrh	r3, [r5, #12]
    1d74:	2b01      	cmp	r3, #1
    1d76:	d908      	bls.n	1d8a <_fwalk_reent+0x36>
    1d78:	220e      	movs	r2, #14
    1d7a:	5eab      	ldrsh	r3, [r5, r2]
    1d7c:	3301      	adds	r3, #1
    1d7e:	d004      	beq.n	1d8a <_fwalk_reent+0x36>
    1d80:	1c38      	adds	r0, r7, #0
    1d82:	1c29      	adds	r1, r5, #0
    1d84:	9b01      	ldr	r3, [sp, #4]
    1d86:	4798      	blx	r3
    1d88:	4306      	orrs	r6, r0
    1d8a:	3568      	adds	r5, #104	; 0x68
    1d8c:	e7ed      	b.n	1d6a <_fwalk_reent+0x16>
    1d8e:	6824      	ldr	r4, [r4, #0]
    1d90:	e7e6      	b.n	1d60 <_fwalk_reent+0xc>
    1d92:	1c30      	adds	r0, r6, #0
    1d94:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

00001d98 <malloc>:
    1d98:	b508      	push	{r3, lr}
    1d9a:	4b03      	ldr	r3, [pc, #12]	; (1da8 <malloc+0x10>)
    1d9c:	1c01      	adds	r1, r0, #0
    1d9e:	6818      	ldr	r0, [r3, #0]
    1da0:	f000 f84a 	bl	1e38 <_malloc_r>
    1da4:	bd08      	pop	{r3, pc}
    1da6:	46c0      	nop			; (mov r8, r8)
    1da8:	20000064 	.word	0x20000064

00001dac <_free_r>:
    1dac:	b530      	push	{r4, r5, lr}
    1dae:	2900      	cmp	r1, #0
    1db0:	d03e      	beq.n	1e30 <_free_r+0x84>
    1db2:	3904      	subs	r1, #4
    1db4:	680b      	ldr	r3, [r1, #0]
    1db6:	2b00      	cmp	r3, #0
    1db8:	da00      	bge.n	1dbc <_free_r+0x10>
    1dba:	18c9      	adds	r1, r1, r3
    1dbc:	4a1d      	ldr	r2, [pc, #116]	; (1e34 <_free_r+0x88>)
    1dbe:	6813      	ldr	r3, [r2, #0]
    1dc0:	1c14      	adds	r4, r2, #0
    1dc2:	2b00      	cmp	r3, #0
    1dc4:	d102      	bne.n	1dcc <_free_r+0x20>
    1dc6:	604b      	str	r3, [r1, #4]
    1dc8:	6011      	str	r1, [r2, #0]
    1dca:	e031      	b.n	1e30 <_free_r+0x84>
    1dcc:	4299      	cmp	r1, r3
    1dce:	d20d      	bcs.n	1dec <_free_r+0x40>
    1dd0:	6808      	ldr	r0, [r1, #0]
    1dd2:	180a      	adds	r2, r1, r0
    1dd4:	429a      	cmp	r2, r3
    1dd6:	d103      	bne.n	1de0 <_free_r+0x34>
    1dd8:	6813      	ldr	r3, [r2, #0]
    1dda:	18c3      	adds	r3, r0, r3
    1ddc:	600b      	str	r3, [r1, #0]
    1dde:	6853      	ldr	r3, [r2, #4]
    1de0:	604b      	str	r3, [r1, #4]
    1de2:	6021      	str	r1, [r4, #0]
    1de4:	e024      	b.n	1e30 <_free_r+0x84>
    1de6:	428a      	cmp	r2, r1
    1de8:	d803      	bhi.n	1df2 <_free_r+0x46>
    1dea:	1c13      	adds	r3, r2, #0
    1dec:	685a      	ldr	r2, [r3, #4]
    1dee:	2a00      	cmp	r2, #0
    1df0:	d1f9      	bne.n	1de6 <_free_r+0x3a>
    1df2:	681d      	ldr	r5, [r3, #0]
    1df4:	195c      	adds	r4, r3, r5
    1df6:	428c      	cmp	r4, r1
    1df8:	d10b      	bne.n	1e12 <_free_r+0x66>
    1dfa:	6809      	ldr	r1, [r1, #0]
    1dfc:	1869      	adds	r1, r5, r1
    1dfe:	1858      	adds	r0, r3, r1
    1e00:	6019      	str	r1, [r3, #0]
    1e02:	4290      	cmp	r0, r2
    1e04:	d114      	bne.n	1e30 <_free_r+0x84>
    1e06:	6810      	ldr	r0, [r2, #0]
    1e08:	6852      	ldr	r2, [r2, #4]
    1e0a:	1809      	adds	r1, r1, r0
    1e0c:	6019      	str	r1, [r3, #0]
    1e0e:	605a      	str	r2, [r3, #4]
    1e10:	e00e      	b.n	1e30 <_free_r+0x84>
    1e12:	428c      	cmp	r4, r1
    1e14:	d902      	bls.n	1e1c <_free_r+0x70>
    1e16:	230c      	movs	r3, #12
    1e18:	6003      	str	r3, [r0, #0]
    1e1a:	e009      	b.n	1e30 <_free_r+0x84>
    1e1c:	6808      	ldr	r0, [r1, #0]
    1e1e:	180c      	adds	r4, r1, r0
    1e20:	4294      	cmp	r4, r2
    1e22:	d103      	bne.n	1e2c <_free_r+0x80>
    1e24:	6814      	ldr	r4, [r2, #0]
    1e26:	6852      	ldr	r2, [r2, #4]
    1e28:	1900      	adds	r0, r0, r4
    1e2a:	6008      	str	r0, [r1, #0]
    1e2c:	604a      	str	r2, [r1, #4]
    1e2e:	6059      	str	r1, [r3, #4]
    1e30:	bd30      	pop	{r4, r5, pc}
    1e32:	46c0      	nop			; (mov r8, r8)
    1e34:	200000c8 	.word	0x200000c8

00001e38 <_malloc_r>:
    1e38:	2303      	movs	r3, #3
    1e3a:	b570      	push	{r4, r5, r6, lr}
    1e3c:	1ccc      	adds	r4, r1, #3
    1e3e:	439c      	bics	r4, r3
    1e40:	3408      	adds	r4, #8
    1e42:	1c05      	adds	r5, r0, #0
    1e44:	2c0c      	cmp	r4, #12
    1e46:	d201      	bcs.n	1e4c <_malloc_r+0x14>
    1e48:	240c      	movs	r4, #12
    1e4a:	e005      	b.n	1e58 <_malloc_r+0x20>
    1e4c:	2c00      	cmp	r4, #0
    1e4e:	da03      	bge.n	1e58 <_malloc_r+0x20>
    1e50:	230c      	movs	r3, #12
    1e52:	2000      	movs	r0, #0
    1e54:	602b      	str	r3, [r5, #0]
    1e56:	e042      	b.n	1ede <_malloc_r+0xa6>
    1e58:	428c      	cmp	r4, r1
    1e5a:	d3f9      	bcc.n	1e50 <_malloc_r+0x18>
    1e5c:	4a20      	ldr	r2, [pc, #128]	; (1ee0 <_malloc_r+0xa8>)
    1e5e:	6813      	ldr	r3, [r2, #0]
    1e60:	1c10      	adds	r0, r2, #0
    1e62:	1c19      	adds	r1, r3, #0
    1e64:	2900      	cmp	r1, #0
    1e66:	d013      	beq.n	1e90 <_malloc_r+0x58>
    1e68:	680a      	ldr	r2, [r1, #0]
    1e6a:	1b12      	subs	r2, r2, r4
    1e6c:	d40d      	bmi.n	1e8a <_malloc_r+0x52>
    1e6e:	2a0b      	cmp	r2, #11
    1e70:	d902      	bls.n	1e78 <_malloc_r+0x40>
    1e72:	600a      	str	r2, [r1, #0]
    1e74:	188b      	adds	r3, r1, r2
    1e76:	e01f      	b.n	1eb8 <_malloc_r+0x80>
    1e78:	428b      	cmp	r3, r1
    1e7a:	d102      	bne.n	1e82 <_malloc_r+0x4a>
    1e7c:	685a      	ldr	r2, [r3, #4]
    1e7e:	6002      	str	r2, [r0, #0]
    1e80:	e01b      	b.n	1eba <_malloc_r+0x82>
    1e82:	684a      	ldr	r2, [r1, #4]
    1e84:	605a      	str	r2, [r3, #4]
    1e86:	1c0b      	adds	r3, r1, #0
    1e88:	e017      	b.n	1eba <_malloc_r+0x82>
    1e8a:	1c0b      	adds	r3, r1, #0
    1e8c:	6849      	ldr	r1, [r1, #4]
    1e8e:	e7e9      	b.n	1e64 <_malloc_r+0x2c>
    1e90:	4e14      	ldr	r6, [pc, #80]	; (1ee4 <_malloc_r+0xac>)
    1e92:	6833      	ldr	r3, [r6, #0]
    1e94:	2b00      	cmp	r3, #0
    1e96:	d103      	bne.n	1ea0 <_malloc_r+0x68>
    1e98:	1c28      	adds	r0, r5, #0
    1e9a:	f000 fb1f 	bl	24dc <_sbrk_r>
    1e9e:	6030      	str	r0, [r6, #0]
    1ea0:	1c28      	adds	r0, r5, #0
    1ea2:	1c21      	adds	r1, r4, #0
    1ea4:	f000 fb1a 	bl	24dc <_sbrk_r>
    1ea8:	1c03      	adds	r3, r0, #0
    1eaa:	1c42      	adds	r2, r0, #1
    1eac:	d0d0      	beq.n	1e50 <_malloc_r+0x18>
    1eae:	2203      	movs	r2, #3
    1eb0:	1cc6      	adds	r6, r0, #3
    1eb2:	4396      	bics	r6, r2
    1eb4:	4286      	cmp	r6, r0
    1eb6:	d10a      	bne.n	1ece <_malloc_r+0x96>
    1eb8:	601c      	str	r4, [r3, #0]
    1eba:	1c18      	adds	r0, r3, #0
    1ebc:	2107      	movs	r1, #7
    1ebe:	300b      	adds	r0, #11
    1ec0:	1d1a      	adds	r2, r3, #4
    1ec2:	4388      	bics	r0, r1
    1ec4:	1a82      	subs	r2, r0, r2
    1ec6:	d00a      	beq.n	1ede <_malloc_r+0xa6>
    1ec8:	4251      	negs	r1, r2
    1eca:	5099      	str	r1, [r3, r2]
    1ecc:	e007      	b.n	1ede <_malloc_r+0xa6>
    1ece:	1a31      	subs	r1, r6, r0
    1ed0:	1c28      	adds	r0, r5, #0
    1ed2:	f000 fb03 	bl	24dc <_sbrk_r>
    1ed6:	1c43      	adds	r3, r0, #1
    1ed8:	d0ba      	beq.n	1e50 <_malloc_r+0x18>
    1eda:	1c33      	adds	r3, r6, #0
    1edc:	e7ec      	b.n	1eb8 <_malloc_r+0x80>
    1ede:	bd70      	pop	{r4, r5, r6, pc}
    1ee0:	200000c8 	.word	0x200000c8
    1ee4:	200000c4 	.word	0x200000c4

00001ee8 <__sfputc_r>:
    1ee8:	6893      	ldr	r3, [r2, #8]
    1eea:	b510      	push	{r4, lr}
    1eec:	3b01      	subs	r3, #1
    1eee:	6093      	str	r3, [r2, #8]
    1ef0:	2b00      	cmp	r3, #0
    1ef2:	da05      	bge.n	1f00 <__sfputc_r+0x18>
    1ef4:	6994      	ldr	r4, [r2, #24]
    1ef6:	42a3      	cmp	r3, r4
    1ef8:	db08      	blt.n	1f0c <__sfputc_r+0x24>
    1efa:	b2cb      	uxtb	r3, r1
    1efc:	2b0a      	cmp	r3, #10
    1efe:	d005      	beq.n	1f0c <__sfputc_r+0x24>
    1f00:	6813      	ldr	r3, [r2, #0]
    1f02:	1c58      	adds	r0, r3, #1
    1f04:	6010      	str	r0, [r2, #0]
    1f06:	7019      	strb	r1, [r3, #0]
    1f08:	b2c8      	uxtb	r0, r1
    1f0a:	e001      	b.n	1f10 <__sfputc_r+0x28>
    1f0c:	f000 fb44 	bl	2598 <__swbuf_r>
    1f10:	bd10      	pop	{r4, pc}

00001f12 <__sfputs_r>:
    1f12:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1f14:	1c06      	adds	r6, r0, #0
    1f16:	1c0f      	adds	r7, r1, #0
    1f18:	1c14      	adds	r4, r2, #0
    1f1a:	18d5      	adds	r5, r2, r3
    1f1c:	42ac      	cmp	r4, r5
    1f1e:	d008      	beq.n	1f32 <__sfputs_r+0x20>
    1f20:	7821      	ldrb	r1, [r4, #0]
    1f22:	1c30      	adds	r0, r6, #0
    1f24:	1c3a      	adds	r2, r7, #0
    1f26:	f7ff ffdf 	bl	1ee8 <__sfputc_r>
    1f2a:	3401      	adds	r4, #1
    1f2c:	1c43      	adds	r3, r0, #1
    1f2e:	d1f5      	bne.n	1f1c <__sfputs_r+0xa>
    1f30:	e000      	b.n	1f34 <__sfputs_r+0x22>
    1f32:	2000      	movs	r0, #0
    1f34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00001f38 <_vfiprintf_r>:
    1f38:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f3a:	b09f      	sub	sp, #124	; 0x7c
    1f3c:	1c06      	adds	r6, r0, #0
    1f3e:	1c0f      	adds	r7, r1, #0
    1f40:	9202      	str	r2, [sp, #8]
    1f42:	9305      	str	r3, [sp, #20]
    1f44:	2800      	cmp	r0, #0
    1f46:	d004      	beq.n	1f52 <_vfiprintf_r+0x1a>
    1f48:	6983      	ldr	r3, [r0, #24]
    1f4a:	2b00      	cmp	r3, #0
    1f4c:	d101      	bne.n	1f52 <_vfiprintf_r+0x1a>
    1f4e:	f7ff fe91 	bl	1c74 <__sinit>
    1f52:	4b79      	ldr	r3, [pc, #484]	; (2138 <STACK_SIZE+0x138>)
    1f54:	429f      	cmp	r7, r3
    1f56:	d101      	bne.n	1f5c <_vfiprintf_r+0x24>
    1f58:	6877      	ldr	r7, [r6, #4]
    1f5a:	e008      	b.n	1f6e <_vfiprintf_r+0x36>
    1f5c:	4b77      	ldr	r3, [pc, #476]	; (213c <STACK_SIZE+0x13c>)
    1f5e:	429f      	cmp	r7, r3
    1f60:	d101      	bne.n	1f66 <_vfiprintf_r+0x2e>
    1f62:	68b7      	ldr	r7, [r6, #8]
    1f64:	e003      	b.n	1f6e <_vfiprintf_r+0x36>
    1f66:	4b76      	ldr	r3, [pc, #472]	; (2140 <STACK_SIZE+0x140>)
    1f68:	429f      	cmp	r7, r3
    1f6a:	d100      	bne.n	1f6e <_vfiprintf_r+0x36>
    1f6c:	68f7      	ldr	r7, [r6, #12]
    1f6e:	89bb      	ldrh	r3, [r7, #12]
    1f70:	071b      	lsls	r3, r3, #28
    1f72:	d50a      	bpl.n	1f8a <_vfiprintf_r+0x52>
    1f74:	693b      	ldr	r3, [r7, #16]
    1f76:	2b00      	cmp	r3, #0
    1f78:	d007      	beq.n	1f8a <_vfiprintf_r+0x52>
    1f7a:	2300      	movs	r3, #0
    1f7c:	ad06      	add	r5, sp, #24
    1f7e:	616b      	str	r3, [r5, #20]
    1f80:	3320      	adds	r3, #32
    1f82:	766b      	strb	r3, [r5, #25]
    1f84:	3310      	adds	r3, #16
    1f86:	76ab      	strb	r3, [r5, #26]
    1f88:	e03d      	b.n	2006 <STACK_SIZE+0x6>
    1f8a:	1c30      	adds	r0, r6, #0
    1f8c:	1c39      	adds	r1, r7, #0
    1f8e:	f000 fb6f 	bl	2670 <__swsetup_r>
    1f92:	2800      	cmp	r0, #0
    1f94:	d0f1      	beq.n	1f7a <_vfiprintf_r+0x42>
    1f96:	2001      	movs	r0, #1
    1f98:	4240      	negs	r0, r0
    1f9a:	e0ca      	b.n	2132 <STACK_SIZE+0x132>
    1f9c:	9a05      	ldr	r2, [sp, #20]
    1f9e:	1d11      	adds	r1, r2, #4
    1fa0:	6812      	ldr	r2, [r2, #0]
    1fa2:	9105      	str	r1, [sp, #20]
    1fa4:	2a00      	cmp	r2, #0
    1fa6:	db7e      	blt.n	20a6 <STACK_SIZE+0xa6>
    1fa8:	9209      	str	r2, [sp, #36]	; 0x24
    1faa:	3401      	adds	r4, #1
    1fac:	7823      	ldrb	r3, [r4, #0]
    1fae:	2b2e      	cmp	r3, #46	; 0x2e
    1fb0:	d100      	bne.n	1fb4 <_vfiprintf_r+0x7c>
    1fb2:	e089      	b.n	20c8 <STACK_SIZE+0xc8>
    1fb4:	7821      	ldrb	r1, [r4, #0]
    1fb6:	4863      	ldr	r0, [pc, #396]	; (2144 <STACK_SIZE+0x144>)
    1fb8:	2203      	movs	r2, #3
    1fba:	f000 fc4b 	bl	2854 <memchr>
    1fbe:	2800      	cmp	r0, #0
    1fc0:	d008      	beq.n	1fd4 <_vfiprintf_r+0x9c>
    1fc2:	4b60      	ldr	r3, [pc, #384]	; (2144 <STACK_SIZE+0x144>)
    1fc4:	3401      	adds	r4, #1
    1fc6:	1ac0      	subs	r0, r0, r3
    1fc8:	2340      	movs	r3, #64	; 0x40
    1fca:	4083      	lsls	r3, r0
    1fcc:	1c18      	adds	r0, r3, #0
    1fce:	682b      	ldr	r3, [r5, #0]
    1fd0:	4318      	orrs	r0, r3
    1fd2:	6028      	str	r0, [r5, #0]
    1fd4:	7821      	ldrb	r1, [r4, #0]
    1fd6:	1c63      	adds	r3, r4, #1
    1fd8:	485b      	ldr	r0, [pc, #364]	; (2148 <STACK_SIZE+0x148>)
    1fda:	2206      	movs	r2, #6
    1fdc:	9302      	str	r3, [sp, #8]
    1fde:	7629      	strb	r1, [r5, #24]
    1fe0:	f000 fc38 	bl	2854 <memchr>
    1fe4:	2800      	cmp	r0, #0
    1fe6:	d100      	bne.n	1fea <_vfiprintf_r+0xb2>
    1fe8:	e091      	b.n	210e <STACK_SIZE+0x10e>
    1fea:	4b58      	ldr	r3, [pc, #352]	; (214c <STACK_SIZE+0x14c>)
    1fec:	2b00      	cmp	r3, #0
    1fee:	d000      	beq.n	1ff2 <_vfiprintf_r+0xba>
    1ff0:	e084      	b.n	20fc <STACK_SIZE+0xfc>
    1ff2:	2207      	movs	r2, #7
    1ff4:	9b05      	ldr	r3, [sp, #20]
    1ff6:	3307      	adds	r3, #7
    1ff8:	4393      	bics	r3, r2
    1ffa:	3308      	adds	r3, #8
    1ffc:	9305      	str	r3, [sp, #20]
    1ffe:	696b      	ldr	r3, [r5, #20]
    2000:	9a03      	ldr	r2, [sp, #12]
    2002:	189b      	adds	r3, r3, r2
    2004:	616b      	str	r3, [r5, #20]
    2006:	9c02      	ldr	r4, [sp, #8]
    2008:	7823      	ldrb	r3, [r4, #0]
    200a:	2b00      	cmp	r3, #0
    200c:	d104      	bne.n	2018 <STACK_SIZE+0x18>
    200e:	9b02      	ldr	r3, [sp, #8]
    2010:	1ae3      	subs	r3, r4, r3
    2012:	9304      	str	r3, [sp, #16]
    2014:	d011      	beq.n	203a <STACK_SIZE+0x3a>
    2016:	e003      	b.n	2020 <STACK_SIZE+0x20>
    2018:	2b25      	cmp	r3, #37	; 0x25
    201a:	d0f8      	beq.n	200e <STACK_SIZE+0xe>
    201c:	3401      	adds	r4, #1
    201e:	e7f3      	b.n	2008 <STACK_SIZE+0x8>
    2020:	9b04      	ldr	r3, [sp, #16]
    2022:	1c30      	adds	r0, r6, #0
    2024:	1c39      	adds	r1, r7, #0
    2026:	9a02      	ldr	r2, [sp, #8]
    2028:	f7ff ff73 	bl	1f12 <__sfputs_r>
    202c:	1c43      	adds	r3, r0, #1
    202e:	d07b      	beq.n	2128 <STACK_SIZE+0x128>
    2030:	696a      	ldr	r2, [r5, #20]
    2032:	9b04      	ldr	r3, [sp, #16]
    2034:	4694      	mov	ip, r2
    2036:	4463      	add	r3, ip
    2038:	616b      	str	r3, [r5, #20]
    203a:	7823      	ldrb	r3, [r4, #0]
    203c:	2b00      	cmp	r3, #0
    203e:	d073      	beq.n	2128 <STACK_SIZE+0x128>
    2040:	2201      	movs	r2, #1
    2042:	2300      	movs	r3, #0
    2044:	4252      	negs	r2, r2
    2046:	606a      	str	r2, [r5, #4]
    2048:	a902      	add	r1, sp, #8
    204a:	3254      	adds	r2, #84	; 0x54
    204c:	1852      	adds	r2, r2, r1
    204e:	3401      	adds	r4, #1
    2050:	602b      	str	r3, [r5, #0]
    2052:	60eb      	str	r3, [r5, #12]
    2054:	60ab      	str	r3, [r5, #8]
    2056:	7013      	strb	r3, [r2, #0]
    2058:	65ab      	str	r3, [r5, #88]	; 0x58
    205a:	7821      	ldrb	r1, [r4, #0]
    205c:	483c      	ldr	r0, [pc, #240]	; (2150 <STACK_SIZE+0x150>)
    205e:	2205      	movs	r2, #5
    2060:	f000 fbf8 	bl	2854 <memchr>
    2064:	2800      	cmp	r0, #0
    2066:	d009      	beq.n	207c <STACK_SIZE+0x7c>
    2068:	4b39      	ldr	r3, [pc, #228]	; (2150 <STACK_SIZE+0x150>)
    206a:	3401      	adds	r4, #1
    206c:	1ac0      	subs	r0, r0, r3
    206e:	2301      	movs	r3, #1
    2070:	4083      	lsls	r3, r0
    2072:	1c18      	adds	r0, r3, #0
    2074:	682b      	ldr	r3, [r5, #0]
    2076:	4318      	orrs	r0, r3
    2078:	6028      	str	r0, [r5, #0]
    207a:	e7ee      	b.n	205a <STACK_SIZE+0x5a>
    207c:	682b      	ldr	r3, [r5, #0]
    207e:	06da      	lsls	r2, r3, #27
    2080:	d504      	bpl.n	208c <STACK_SIZE+0x8c>
    2082:	2253      	movs	r2, #83	; 0x53
    2084:	2120      	movs	r1, #32
    2086:	a802      	add	r0, sp, #8
    2088:	1812      	adds	r2, r2, r0
    208a:	7011      	strb	r1, [r2, #0]
    208c:	071a      	lsls	r2, r3, #28
    208e:	d504      	bpl.n	209a <STACK_SIZE+0x9a>
    2090:	2253      	movs	r2, #83	; 0x53
    2092:	212b      	movs	r1, #43	; 0x2b
    2094:	a802      	add	r0, sp, #8
    2096:	1812      	adds	r2, r2, r0
    2098:	7011      	strb	r1, [r2, #0]
    209a:	7822      	ldrb	r2, [r4, #0]
    209c:	2a2a      	cmp	r2, #42	; 0x2a
    209e:	d100      	bne.n	20a2 <STACK_SIZE+0xa2>
    20a0:	e77c      	b.n	1f9c <_vfiprintf_r+0x64>
    20a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    20a4:	e005      	b.n	20b2 <STACK_SIZE+0xb2>
    20a6:	4252      	negs	r2, r2
    20a8:	60ea      	str	r2, [r5, #12]
    20aa:	2202      	movs	r2, #2
    20ac:	4313      	orrs	r3, r2
    20ae:	602b      	str	r3, [r5, #0]
    20b0:	e77b      	b.n	1faa <_vfiprintf_r+0x72>
    20b2:	7822      	ldrb	r2, [r4, #0]
    20b4:	3a30      	subs	r2, #48	; 0x30
    20b6:	2a09      	cmp	r2, #9
    20b8:	d804      	bhi.n	20c4 <STACK_SIZE+0xc4>
    20ba:	210a      	movs	r1, #10
    20bc:	434b      	muls	r3, r1
    20be:	3401      	adds	r4, #1
    20c0:	189b      	adds	r3, r3, r2
    20c2:	e7f6      	b.n	20b2 <STACK_SIZE+0xb2>
    20c4:	9309      	str	r3, [sp, #36]	; 0x24
    20c6:	e771      	b.n	1fac <_vfiprintf_r+0x74>
    20c8:	7863      	ldrb	r3, [r4, #1]
    20ca:	2b2a      	cmp	r3, #42	; 0x2a
    20cc:	d109      	bne.n	20e2 <STACK_SIZE+0xe2>
    20ce:	9b05      	ldr	r3, [sp, #20]
    20d0:	3402      	adds	r4, #2
    20d2:	1d1a      	adds	r2, r3, #4
    20d4:	681b      	ldr	r3, [r3, #0]
    20d6:	9205      	str	r2, [sp, #20]
    20d8:	2b00      	cmp	r3, #0
    20da:	da0d      	bge.n	20f8 <STACK_SIZE+0xf8>
    20dc:	2301      	movs	r3, #1
    20de:	425b      	negs	r3, r3
    20e0:	e00a      	b.n	20f8 <STACK_SIZE+0xf8>
    20e2:	2300      	movs	r3, #0
    20e4:	3401      	adds	r4, #1
    20e6:	7822      	ldrb	r2, [r4, #0]
    20e8:	3a30      	subs	r2, #48	; 0x30
    20ea:	2a09      	cmp	r2, #9
    20ec:	d804      	bhi.n	20f8 <STACK_SIZE+0xf8>
    20ee:	210a      	movs	r1, #10
    20f0:	434b      	muls	r3, r1
    20f2:	3401      	adds	r4, #1
    20f4:	189b      	adds	r3, r3, r2
    20f6:	e7f6      	b.n	20e6 <STACK_SIZE+0xe6>
    20f8:	9307      	str	r3, [sp, #28]
    20fa:	e75b      	b.n	1fb4 <_vfiprintf_r+0x7c>
    20fc:	ab05      	add	r3, sp, #20
    20fe:	9300      	str	r3, [sp, #0]
    2100:	1c30      	adds	r0, r6, #0
    2102:	1c29      	adds	r1, r5, #0
    2104:	1c3a      	adds	r2, r7, #0
    2106:	4b13      	ldr	r3, [pc, #76]	; (2154 <STACK_SIZE+0x154>)
    2108:	e000      	b.n	210c <STACK_SIZE+0x10c>
    210a:	bf00      	nop
    210c:	e007      	b.n	211e <STACK_SIZE+0x11e>
    210e:	ab05      	add	r3, sp, #20
    2110:	9300      	str	r3, [sp, #0]
    2112:	1c30      	adds	r0, r6, #0
    2114:	1c29      	adds	r1, r5, #0
    2116:	1c3a      	adds	r2, r7, #0
    2118:	4b0e      	ldr	r3, [pc, #56]	; (2154 <STACK_SIZE+0x154>)
    211a:	f000 f88b 	bl	2234 <_printf_i>
    211e:	9003      	str	r0, [sp, #12]
    2120:	9b03      	ldr	r3, [sp, #12]
    2122:	3301      	adds	r3, #1
    2124:	d000      	beq.n	2128 <STACK_SIZE+0x128>
    2126:	e76a      	b.n	1ffe <_vfiprintf_r+0xc6>
    2128:	89bb      	ldrh	r3, [r7, #12]
    212a:	065b      	lsls	r3, r3, #25
    212c:	d500      	bpl.n	2130 <STACK_SIZE+0x130>
    212e:	e732      	b.n	1f96 <_vfiprintf_r+0x5e>
    2130:	980b      	ldr	r0, [sp, #44]	; 0x2c
    2132:	b01f      	add	sp, #124	; 0x7c
    2134:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2136:	46c0      	nop			; (mov r8, r8)
    2138:	00002964 	.word	0x00002964
    213c:	00002984 	.word	0x00002984
    2140:	000029a4 	.word	0x000029a4
    2144:	000029ca 	.word	0x000029ca
    2148:	000029ce 	.word	0x000029ce
    214c:	00000000 	.word	0x00000000
    2150:	000029c4 	.word	0x000029c4
    2154:	00001f13 	.word	0x00001f13

00002158 <_printf_common>:
    2158:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    215a:	1c17      	adds	r7, r2, #0
    215c:	9301      	str	r3, [sp, #4]
    215e:	690a      	ldr	r2, [r1, #16]
    2160:	688b      	ldr	r3, [r1, #8]
    2162:	9000      	str	r0, [sp, #0]
    2164:	1c0c      	adds	r4, r1, #0
    2166:	4293      	cmp	r3, r2
    2168:	da00      	bge.n	216c <_printf_common+0x14>
    216a:	1c13      	adds	r3, r2, #0
    216c:	1c22      	adds	r2, r4, #0
    216e:	603b      	str	r3, [r7, #0]
    2170:	3243      	adds	r2, #67	; 0x43
    2172:	7812      	ldrb	r2, [r2, #0]
    2174:	2a00      	cmp	r2, #0
    2176:	d001      	beq.n	217c <_printf_common+0x24>
    2178:	3301      	adds	r3, #1
    217a:	603b      	str	r3, [r7, #0]
    217c:	6823      	ldr	r3, [r4, #0]
    217e:	069b      	lsls	r3, r3, #26
    2180:	d502      	bpl.n	2188 <_printf_common+0x30>
    2182:	683b      	ldr	r3, [r7, #0]
    2184:	3302      	adds	r3, #2
    2186:	603b      	str	r3, [r7, #0]
    2188:	2506      	movs	r5, #6
    218a:	6823      	ldr	r3, [r4, #0]
    218c:	401d      	ands	r5, r3
    218e:	d01e      	beq.n	21ce <_printf_common+0x76>
    2190:	1c23      	adds	r3, r4, #0
    2192:	3343      	adds	r3, #67	; 0x43
    2194:	781b      	ldrb	r3, [r3, #0]
    2196:	1e5a      	subs	r2, r3, #1
    2198:	4193      	sbcs	r3, r2
    219a:	6822      	ldr	r2, [r4, #0]
    219c:	0692      	lsls	r2, r2, #26
    219e:	d51c      	bpl.n	21da <_printf_common+0x82>
    21a0:	2030      	movs	r0, #48	; 0x30
    21a2:	18e1      	adds	r1, r4, r3
    21a4:	3140      	adds	r1, #64	; 0x40
    21a6:	70c8      	strb	r0, [r1, #3]
    21a8:	1c21      	adds	r1, r4, #0
    21aa:	1c5a      	adds	r2, r3, #1
    21ac:	3145      	adds	r1, #69	; 0x45
    21ae:	7809      	ldrb	r1, [r1, #0]
    21b0:	18a2      	adds	r2, r4, r2
    21b2:	3240      	adds	r2, #64	; 0x40
    21b4:	3302      	adds	r3, #2
    21b6:	70d1      	strb	r1, [r2, #3]
    21b8:	e00f      	b.n	21da <_printf_common+0x82>
    21ba:	1c22      	adds	r2, r4, #0
    21bc:	2301      	movs	r3, #1
    21be:	9800      	ldr	r0, [sp, #0]
    21c0:	9901      	ldr	r1, [sp, #4]
    21c2:	3219      	adds	r2, #25
    21c4:	9e08      	ldr	r6, [sp, #32]
    21c6:	47b0      	blx	r6
    21c8:	1c43      	adds	r3, r0, #1
    21ca:	d00e      	beq.n	21ea <_printf_common+0x92>
    21cc:	3501      	adds	r5, #1
    21ce:	68e3      	ldr	r3, [r4, #12]
    21d0:	683a      	ldr	r2, [r7, #0]
    21d2:	1a9b      	subs	r3, r3, r2
    21d4:	429d      	cmp	r5, r3
    21d6:	dbf0      	blt.n	21ba <_printf_common+0x62>
    21d8:	e7da      	b.n	2190 <_printf_common+0x38>
    21da:	1c22      	adds	r2, r4, #0
    21dc:	9800      	ldr	r0, [sp, #0]
    21de:	9901      	ldr	r1, [sp, #4]
    21e0:	3243      	adds	r2, #67	; 0x43
    21e2:	9d08      	ldr	r5, [sp, #32]
    21e4:	47a8      	blx	r5
    21e6:	1c43      	adds	r3, r0, #1
    21e8:	d102      	bne.n	21f0 <_printf_common+0x98>
    21ea:	2001      	movs	r0, #1
    21ec:	4240      	negs	r0, r0
    21ee:	e020      	b.n	2232 <_printf_common+0xda>
    21f0:	2306      	movs	r3, #6
    21f2:	6820      	ldr	r0, [r4, #0]
    21f4:	68e1      	ldr	r1, [r4, #12]
    21f6:	683a      	ldr	r2, [r7, #0]
    21f8:	4003      	ands	r3, r0
    21fa:	2500      	movs	r5, #0
    21fc:	2b04      	cmp	r3, #4
    21fe:	d103      	bne.n	2208 <_printf_common+0xb0>
    2200:	1a8d      	subs	r5, r1, r2
    2202:	43eb      	mvns	r3, r5
    2204:	17db      	asrs	r3, r3, #31
    2206:	401d      	ands	r5, r3
    2208:	68a3      	ldr	r3, [r4, #8]
    220a:	6922      	ldr	r2, [r4, #16]
    220c:	4293      	cmp	r3, r2
    220e:	dd01      	ble.n	2214 <_printf_common+0xbc>
    2210:	1a9b      	subs	r3, r3, r2
    2212:	18ed      	adds	r5, r5, r3
    2214:	2700      	movs	r7, #0
    2216:	42af      	cmp	r7, r5
    2218:	da0a      	bge.n	2230 <_printf_common+0xd8>
    221a:	1c22      	adds	r2, r4, #0
    221c:	2301      	movs	r3, #1
    221e:	9800      	ldr	r0, [sp, #0]
    2220:	9901      	ldr	r1, [sp, #4]
    2222:	321a      	adds	r2, #26
    2224:	9e08      	ldr	r6, [sp, #32]
    2226:	47b0      	blx	r6
    2228:	1c43      	adds	r3, r0, #1
    222a:	d0de      	beq.n	21ea <_printf_common+0x92>
    222c:	3701      	adds	r7, #1
    222e:	e7f2      	b.n	2216 <_printf_common+0xbe>
    2230:	2000      	movs	r0, #0
    2232:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00002234 <_printf_i>:
    2234:	b5f0      	push	{r4, r5, r6, r7, lr}
    2236:	b08b      	sub	sp, #44	; 0x2c
    2238:	9206      	str	r2, [sp, #24]
    223a:	1c0a      	adds	r2, r1, #0
    223c:	3243      	adds	r2, #67	; 0x43
    223e:	9307      	str	r3, [sp, #28]
    2240:	9005      	str	r0, [sp, #20]
    2242:	9204      	str	r2, [sp, #16]
    2244:	7e0a      	ldrb	r2, [r1, #24]
    2246:	1c0c      	adds	r4, r1, #0
    2248:	9b10      	ldr	r3, [sp, #64]	; 0x40
    224a:	2a6e      	cmp	r2, #110	; 0x6e
    224c:	d100      	bne.n	2250 <_printf_i+0x1c>
    224e:	e0a8      	b.n	23a2 <_printf_i+0x16e>
    2250:	d811      	bhi.n	2276 <_printf_i+0x42>
    2252:	2a63      	cmp	r2, #99	; 0x63
    2254:	d022      	beq.n	229c <_printf_i+0x68>
    2256:	d809      	bhi.n	226c <_printf_i+0x38>
    2258:	2a00      	cmp	r2, #0
    225a:	d100      	bne.n	225e <_printf_i+0x2a>
    225c:	e0b2      	b.n	23c4 <_printf_i+0x190>
    225e:	2a58      	cmp	r2, #88	; 0x58
    2260:	d000      	beq.n	2264 <_printf_i+0x30>
    2262:	e0c2      	b.n	23ea <_printf_i+0x1b6>
    2264:	3145      	adds	r1, #69	; 0x45
    2266:	700a      	strb	r2, [r1, #0]
    2268:	4a7c      	ldr	r2, [pc, #496]	; (245c <_printf_i+0x228>)
    226a:	e04f      	b.n	230c <_printf_i+0xd8>
    226c:	2a64      	cmp	r2, #100	; 0x64
    226e:	d01d      	beq.n	22ac <_printf_i+0x78>
    2270:	2a69      	cmp	r2, #105	; 0x69
    2272:	d01b      	beq.n	22ac <_printf_i+0x78>
    2274:	e0b9      	b.n	23ea <_printf_i+0x1b6>
    2276:	2a73      	cmp	r2, #115	; 0x73
    2278:	d100      	bne.n	227c <_printf_i+0x48>
    227a:	e0a7      	b.n	23cc <_printf_i+0x198>
    227c:	d809      	bhi.n	2292 <_printf_i+0x5e>
    227e:	2a6f      	cmp	r2, #111	; 0x6f
    2280:	d029      	beq.n	22d6 <_printf_i+0xa2>
    2282:	2a70      	cmp	r2, #112	; 0x70
    2284:	d000      	beq.n	2288 <_printf_i+0x54>
    2286:	e0b0      	b.n	23ea <_printf_i+0x1b6>
    2288:	2220      	movs	r2, #32
    228a:	6809      	ldr	r1, [r1, #0]
    228c:	430a      	orrs	r2, r1
    228e:	6022      	str	r2, [r4, #0]
    2290:	e037      	b.n	2302 <_printf_i+0xce>
    2292:	2a75      	cmp	r2, #117	; 0x75
    2294:	d01f      	beq.n	22d6 <_printf_i+0xa2>
    2296:	2a78      	cmp	r2, #120	; 0x78
    2298:	d033      	beq.n	2302 <_printf_i+0xce>
    229a:	e0a6      	b.n	23ea <_printf_i+0x1b6>
    229c:	1c0e      	adds	r6, r1, #0
    229e:	681a      	ldr	r2, [r3, #0]
    22a0:	3642      	adds	r6, #66	; 0x42
    22a2:	1d11      	adds	r1, r2, #4
    22a4:	6019      	str	r1, [r3, #0]
    22a6:	6813      	ldr	r3, [r2, #0]
    22a8:	7033      	strb	r3, [r6, #0]
    22aa:	e0a1      	b.n	23f0 <_printf_i+0x1bc>
    22ac:	6821      	ldr	r1, [r4, #0]
    22ae:	681a      	ldr	r2, [r3, #0]
    22b0:	0608      	lsls	r0, r1, #24
    22b2:	d406      	bmi.n	22c2 <_printf_i+0x8e>
    22b4:	0649      	lsls	r1, r1, #25
    22b6:	d504      	bpl.n	22c2 <_printf_i+0x8e>
    22b8:	1d11      	adds	r1, r2, #4
    22ba:	6019      	str	r1, [r3, #0]
    22bc:	2300      	movs	r3, #0
    22be:	5ed5      	ldrsh	r5, [r2, r3]
    22c0:	e002      	b.n	22c8 <_printf_i+0x94>
    22c2:	1d11      	adds	r1, r2, #4
    22c4:	6019      	str	r1, [r3, #0]
    22c6:	6815      	ldr	r5, [r2, #0]
    22c8:	2d00      	cmp	r5, #0
    22ca:	da3b      	bge.n	2344 <_printf_i+0x110>
    22cc:	232d      	movs	r3, #45	; 0x2d
    22ce:	9a04      	ldr	r2, [sp, #16]
    22d0:	426d      	negs	r5, r5
    22d2:	7013      	strb	r3, [r2, #0]
    22d4:	e036      	b.n	2344 <_printf_i+0x110>
    22d6:	6821      	ldr	r1, [r4, #0]
    22d8:	681a      	ldr	r2, [r3, #0]
    22da:	0608      	lsls	r0, r1, #24
    22dc:	d406      	bmi.n	22ec <_printf_i+0xb8>
    22de:	0649      	lsls	r1, r1, #25
    22e0:	d504      	bpl.n	22ec <_printf_i+0xb8>
    22e2:	6815      	ldr	r5, [r2, #0]
    22e4:	1d11      	adds	r1, r2, #4
    22e6:	6019      	str	r1, [r3, #0]
    22e8:	b2ad      	uxth	r5, r5
    22ea:	e002      	b.n	22f2 <_printf_i+0xbe>
    22ec:	1d11      	adds	r1, r2, #4
    22ee:	6019      	str	r1, [r3, #0]
    22f0:	6815      	ldr	r5, [r2, #0]
    22f2:	4b5a      	ldr	r3, [pc, #360]	; (245c <_printf_i+0x228>)
    22f4:	7e22      	ldrb	r2, [r4, #24]
    22f6:	9303      	str	r3, [sp, #12]
    22f8:	270a      	movs	r7, #10
    22fa:	2a6f      	cmp	r2, #111	; 0x6f
    22fc:	d11d      	bne.n	233a <_printf_i+0x106>
    22fe:	2708      	movs	r7, #8
    2300:	e01b      	b.n	233a <_printf_i+0x106>
    2302:	1c22      	adds	r2, r4, #0
    2304:	2178      	movs	r1, #120	; 0x78
    2306:	3245      	adds	r2, #69	; 0x45
    2308:	7011      	strb	r1, [r2, #0]
    230a:	4a55      	ldr	r2, [pc, #340]	; (2460 <_printf_i+0x22c>)
    230c:	6819      	ldr	r1, [r3, #0]
    230e:	9203      	str	r2, [sp, #12]
    2310:	1d08      	adds	r0, r1, #4
    2312:	6822      	ldr	r2, [r4, #0]
    2314:	6018      	str	r0, [r3, #0]
    2316:	680d      	ldr	r5, [r1, #0]
    2318:	0610      	lsls	r0, r2, #24
    231a:	d402      	bmi.n	2322 <_printf_i+0xee>
    231c:	0650      	lsls	r0, r2, #25
    231e:	d500      	bpl.n	2322 <_printf_i+0xee>
    2320:	b2ad      	uxth	r5, r5
    2322:	07d3      	lsls	r3, r2, #31
    2324:	d502      	bpl.n	232c <_printf_i+0xf8>
    2326:	2320      	movs	r3, #32
    2328:	431a      	orrs	r2, r3
    232a:	6022      	str	r2, [r4, #0]
    232c:	2710      	movs	r7, #16
    232e:	2d00      	cmp	r5, #0
    2330:	d103      	bne.n	233a <_printf_i+0x106>
    2332:	2320      	movs	r3, #32
    2334:	6822      	ldr	r2, [r4, #0]
    2336:	439a      	bics	r2, r3
    2338:	6022      	str	r2, [r4, #0]
    233a:	1c23      	adds	r3, r4, #0
    233c:	2200      	movs	r2, #0
    233e:	3343      	adds	r3, #67	; 0x43
    2340:	701a      	strb	r2, [r3, #0]
    2342:	e002      	b.n	234a <_printf_i+0x116>
    2344:	270a      	movs	r7, #10
    2346:	4b45      	ldr	r3, [pc, #276]	; (245c <_printf_i+0x228>)
    2348:	9303      	str	r3, [sp, #12]
    234a:	6863      	ldr	r3, [r4, #4]
    234c:	60a3      	str	r3, [r4, #8]
    234e:	2b00      	cmp	r3, #0
    2350:	db03      	blt.n	235a <_printf_i+0x126>
    2352:	2204      	movs	r2, #4
    2354:	6821      	ldr	r1, [r4, #0]
    2356:	4391      	bics	r1, r2
    2358:	6021      	str	r1, [r4, #0]
    235a:	2d00      	cmp	r5, #0
    235c:	d102      	bne.n	2364 <_printf_i+0x130>
    235e:	9e04      	ldr	r6, [sp, #16]
    2360:	2b00      	cmp	r3, #0
    2362:	d00e      	beq.n	2382 <_printf_i+0x14e>
    2364:	9e04      	ldr	r6, [sp, #16]
    2366:	1c28      	adds	r0, r5, #0
    2368:	1c39      	adds	r1, r7, #0
    236a:	f7ff fa5f 	bl	182c <__aeabi_uidivmod>
    236e:	9b03      	ldr	r3, [sp, #12]
    2370:	3e01      	subs	r6, #1
    2372:	5c5b      	ldrb	r3, [r3, r1]
    2374:	1c28      	adds	r0, r5, #0
    2376:	7033      	strb	r3, [r6, #0]
    2378:	1c39      	adds	r1, r7, #0
    237a:	f7ff f9d1 	bl	1720 <__aeabi_uidiv>
    237e:	1e05      	subs	r5, r0, #0
    2380:	d1f1      	bne.n	2366 <_printf_i+0x132>
    2382:	2f08      	cmp	r7, #8
    2384:	d109      	bne.n	239a <_printf_i+0x166>
    2386:	6823      	ldr	r3, [r4, #0]
    2388:	07db      	lsls	r3, r3, #31
    238a:	d506      	bpl.n	239a <_printf_i+0x166>
    238c:	6863      	ldr	r3, [r4, #4]
    238e:	6922      	ldr	r2, [r4, #16]
    2390:	4293      	cmp	r3, r2
    2392:	dc02      	bgt.n	239a <_printf_i+0x166>
    2394:	2330      	movs	r3, #48	; 0x30
    2396:	3e01      	subs	r6, #1
    2398:	7033      	strb	r3, [r6, #0]
    239a:	9b04      	ldr	r3, [sp, #16]
    239c:	1b9b      	subs	r3, r3, r6
    239e:	6123      	str	r3, [r4, #16]
    23a0:	e02b      	b.n	23fa <_printf_i+0x1c6>
    23a2:	6809      	ldr	r1, [r1, #0]
    23a4:	681a      	ldr	r2, [r3, #0]
    23a6:	0608      	lsls	r0, r1, #24
    23a8:	d407      	bmi.n	23ba <_printf_i+0x186>
    23aa:	0649      	lsls	r1, r1, #25
    23ac:	d505      	bpl.n	23ba <_printf_i+0x186>
    23ae:	1d11      	adds	r1, r2, #4
    23b0:	6019      	str	r1, [r3, #0]
    23b2:	6813      	ldr	r3, [r2, #0]
    23b4:	8aa2      	ldrh	r2, [r4, #20]
    23b6:	801a      	strh	r2, [r3, #0]
    23b8:	e004      	b.n	23c4 <_printf_i+0x190>
    23ba:	1d11      	adds	r1, r2, #4
    23bc:	6019      	str	r1, [r3, #0]
    23be:	6813      	ldr	r3, [r2, #0]
    23c0:	6962      	ldr	r2, [r4, #20]
    23c2:	601a      	str	r2, [r3, #0]
    23c4:	2300      	movs	r3, #0
    23c6:	9e04      	ldr	r6, [sp, #16]
    23c8:	6123      	str	r3, [r4, #16]
    23ca:	e016      	b.n	23fa <_printf_i+0x1c6>
    23cc:	681a      	ldr	r2, [r3, #0]
    23ce:	1d11      	adds	r1, r2, #4
    23d0:	6019      	str	r1, [r3, #0]
    23d2:	6816      	ldr	r6, [r2, #0]
    23d4:	2100      	movs	r1, #0
    23d6:	1c30      	adds	r0, r6, #0
    23d8:	6862      	ldr	r2, [r4, #4]
    23da:	f000 fa3b 	bl	2854 <memchr>
    23de:	2800      	cmp	r0, #0
    23e0:	d001      	beq.n	23e6 <_printf_i+0x1b2>
    23e2:	1b80      	subs	r0, r0, r6
    23e4:	6060      	str	r0, [r4, #4]
    23e6:	6863      	ldr	r3, [r4, #4]
    23e8:	e003      	b.n	23f2 <_printf_i+0x1be>
    23ea:	1c26      	adds	r6, r4, #0
    23ec:	3642      	adds	r6, #66	; 0x42
    23ee:	7032      	strb	r2, [r6, #0]
    23f0:	2301      	movs	r3, #1
    23f2:	6123      	str	r3, [r4, #16]
    23f4:	2300      	movs	r3, #0
    23f6:	9a04      	ldr	r2, [sp, #16]
    23f8:	7013      	strb	r3, [r2, #0]
    23fa:	9b07      	ldr	r3, [sp, #28]
    23fc:	9805      	ldr	r0, [sp, #20]
    23fe:	9300      	str	r3, [sp, #0]
    2400:	1c21      	adds	r1, r4, #0
    2402:	9b06      	ldr	r3, [sp, #24]
    2404:	aa09      	add	r2, sp, #36	; 0x24
    2406:	f7ff fea7 	bl	2158 <_printf_common>
    240a:	1c43      	adds	r3, r0, #1
    240c:	d102      	bne.n	2414 <_printf_i+0x1e0>
    240e:	2001      	movs	r0, #1
    2410:	4240      	negs	r0, r0
    2412:	e021      	b.n	2458 <_printf_i+0x224>
    2414:	6923      	ldr	r3, [r4, #16]
    2416:	9805      	ldr	r0, [sp, #20]
    2418:	9906      	ldr	r1, [sp, #24]
    241a:	1c32      	adds	r2, r6, #0
    241c:	9d07      	ldr	r5, [sp, #28]
    241e:	47a8      	blx	r5
    2420:	1c43      	adds	r3, r0, #1
    2422:	d0f4      	beq.n	240e <_printf_i+0x1da>
    2424:	6823      	ldr	r3, [r4, #0]
    2426:	079b      	lsls	r3, r3, #30
    2428:	d405      	bmi.n	2436 <_printf_i+0x202>
    242a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    242c:	68e0      	ldr	r0, [r4, #12]
    242e:	4298      	cmp	r0, r3
    2430:	da12      	bge.n	2458 <_printf_i+0x224>
    2432:	1c18      	adds	r0, r3, #0
    2434:	e010      	b.n	2458 <_printf_i+0x224>
    2436:	2500      	movs	r5, #0
    2438:	68e3      	ldr	r3, [r4, #12]
    243a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    243c:	1a9b      	subs	r3, r3, r2
    243e:	429d      	cmp	r5, r3
    2440:	daf3      	bge.n	242a <_printf_i+0x1f6>
    2442:	1c22      	adds	r2, r4, #0
    2444:	2301      	movs	r3, #1
    2446:	9805      	ldr	r0, [sp, #20]
    2448:	9906      	ldr	r1, [sp, #24]
    244a:	3219      	adds	r2, #25
    244c:	9e07      	ldr	r6, [sp, #28]
    244e:	47b0      	blx	r6
    2450:	1c43      	adds	r3, r0, #1
    2452:	d0dc      	beq.n	240e <_printf_i+0x1da>
    2454:	3501      	adds	r5, #1
    2456:	e7ef      	b.n	2438 <_printf_i+0x204>
    2458:	b00b      	add	sp, #44	; 0x2c
    245a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    245c:	000029d5 	.word	0x000029d5
    2460:	000029e6 	.word	0x000029e6

00002464 <_putc_r>:
    2464:	b570      	push	{r4, r5, r6, lr}
    2466:	1c05      	adds	r5, r0, #0
    2468:	1c0e      	adds	r6, r1, #0
    246a:	1c14      	adds	r4, r2, #0
    246c:	2800      	cmp	r0, #0
    246e:	d004      	beq.n	247a <_putc_r+0x16>
    2470:	6983      	ldr	r3, [r0, #24]
    2472:	2b00      	cmp	r3, #0
    2474:	d101      	bne.n	247a <_putc_r+0x16>
    2476:	f7ff fbfd 	bl	1c74 <__sinit>
    247a:	4b15      	ldr	r3, [pc, #84]	; (24d0 <_putc_r+0x6c>)
    247c:	429c      	cmp	r4, r3
    247e:	d101      	bne.n	2484 <_putc_r+0x20>
    2480:	686c      	ldr	r4, [r5, #4]
    2482:	e008      	b.n	2496 <_putc_r+0x32>
    2484:	4b13      	ldr	r3, [pc, #76]	; (24d4 <_putc_r+0x70>)
    2486:	429c      	cmp	r4, r3
    2488:	d101      	bne.n	248e <_putc_r+0x2a>
    248a:	68ac      	ldr	r4, [r5, #8]
    248c:	e003      	b.n	2496 <_putc_r+0x32>
    248e:	4b12      	ldr	r3, [pc, #72]	; (24d8 <_putc_r+0x74>)
    2490:	429c      	cmp	r4, r3
    2492:	d100      	bne.n	2496 <_putc_r+0x32>
    2494:	68ec      	ldr	r4, [r5, #12]
    2496:	68a3      	ldr	r3, [r4, #8]
    2498:	3b01      	subs	r3, #1
    249a:	60a3      	str	r3, [r4, #8]
    249c:	2b00      	cmp	r3, #0
    249e:	da10      	bge.n	24c2 <_putc_r+0x5e>
    24a0:	69a2      	ldr	r2, [r4, #24]
    24a2:	4293      	cmp	r3, r2
    24a4:	db07      	blt.n	24b6 <_putc_r+0x52>
    24a6:	6823      	ldr	r3, [r4, #0]
    24a8:	701e      	strb	r6, [r3, #0]
    24aa:	6823      	ldr	r3, [r4, #0]
    24ac:	7819      	ldrb	r1, [r3, #0]
    24ae:	290a      	cmp	r1, #10
    24b0:	d10a      	bne.n	24c8 <_putc_r+0x64>
    24b2:	1c28      	adds	r0, r5, #0
    24b4:	e001      	b.n	24ba <_putc_r+0x56>
    24b6:	1c28      	adds	r0, r5, #0
    24b8:	1c31      	adds	r1, r6, #0
    24ba:	1c22      	adds	r2, r4, #0
    24bc:	f000 f86c 	bl	2598 <__swbuf_r>
    24c0:	e005      	b.n	24ce <_putc_r+0x6a>
    24c2:	6823      	ldr	r3, [r4, #0]
    24c4:	701e      	strb	r6, [r3, #0]
    24c6:	6823      	ldr	r3, [r4, #0]
    24c8:	1c5a      	adds	r2, r3, #1
    24ca:	6022      	str	r2, [r4, #0]
    24cc:	7818      	ldrb	r0, [r3, #0]
    24ce:	bd70      	pop	{r4, r5, r6, pc}
    24d0:	00002964 	.word	0x00002964
    24d4:	00002984 	.word	0x00002984
    24d8:	000029a4 	.word	0x000029a4

000024dc <_sbrk_r>:
    24dc:	b538      	push	{r3, r4, r5, lr}
    24de:	2300      	movs	r3, #0
    24e0:	4c06      	ldr	r4, [pc, #24]	; (24fc <_sbrk_r+0x20>)
    24e2:	1c05      	adds	r5, r0, #0
    24e4:	1c08      	adds	r0, r1, #0
    24e6:	6023      	str	r3, [r4, #0]
    24e8:	f7ff f80e 	bl	1508 <_sbrk>
    24ec:	1c43      	adds	r3, r0, #1
    24ee:	d103      	bne.n	24f8 <_sbrk_r+0x1c>
    24f0:	6823      	ldr	r3, [r4, #0]
    24f2:	2b00      	cmp	r3, #0
    24f4:	d000      	beq.n	24f8 <_sbrk_r+0x1c>
    24f6:	602b      	str	r3, [r5, #0]
    24f8:	bd38      	pop	{r3, r4, r5, pc}
    24fa:	46c0      	nop			; (mov r8, r8)
    24fc:	20000124 	.word	0x20000124

00002500 <__sread>:
    2500:	b538      	push	{r3, r4, r5, lr}
    2502:	1c0c      	adds	r4, r1, #0
    2504:	250e      	movs	r5, #14
    2506:	5f49      	ldrsh	r1, [r1, r5]
    2508:	f000 f9b0 	bl	286c <_read_r>
    250c:	2800      	cmp	r0, #0
    250e:	db03      	blt.n	2518 <__sread+0x18>
    2510:	6d63      	ldr	r3, [r4, #84]	; 0x54
    2512:	181b      	adds	r3, r3, r0
    2514:	6563      	str	r3, [r4, #84]	; 0x54
    2516:	e003      	b.n	2520 <__sread+0x20>
    2518:	89a2      	ldrh	r2, [r4, #12]
    251a:	4b02      	ldr	r3, [pc, #8]	; (2524 <__sread+0x24>)
    251c:	4013      	ands	r3, r2
    251e:	81a3      	strh	r3, [r4, #12]
    2520:	bd38      	pop	{r3, r4, r5, pc}
    2522:	46c0      	nop			; (mov r8, r8)
    2524:	ffffefff 	.word	0xffffefff

00002528 <__swrite>:
    2528:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    252a:	1c1e      	adds	r6, r3, #0
    252c:	898b      	ldrh	r3, [r1, #12]
    252e:	1c05      	adds	r5, r0, #0
    2530:	1c0c      	adds	r4, r1, #0
    2532:	1c17      	adds	r7, r2, #0
    2534:	05db      	lsls	r3, r3, #23
    2536:	d505      	bpl.n	2544 <__swrite+0x1c>
    2538:	230e      	movs	r3, #14
    253a:	5ec9      	ldrsh	r1, [r1, r3]
    253c:	2200      	movs	r2, #0
    253e:	2302      	movs	r3, #2
    2540:	f000 f91c 	bl	277c <_lseek_r>
    2544:	89a2      	ldrh	r2, [r4, #12]
    2546:	4b05      	ldr	r3, [pc, #20]	; (255c <__swrite+0x34>)
    2548:	1c28      	adds	r0, r5, #0
    254a:	4013      	ands	r3, r2
    254c:	81a3      	strh	r3, [r4, #12]
    254e:	1c3a      	adds	r2, r7, #0
    2550:	230e      	movs	r3, #14
    2552:	5ee1      	ldrsh	r1, [r4, r3]
    2554:	1c33      	adds	r3, r6, #0
    2556:	f000 f877 	bl	2648 <_write_r>
    255a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    255c:	ffffefff 	.word	0xffffefff

00002560 <__sseek>:
    2560:	b538      	push	{r3, r4, r5, lr}
    2562:	1c0c      	adds	r4, r1, #0
    2564:	250e      	movs	r5, #14
    2566:	5f49      	ldrsh	r1, [r1, r5]
    2568:	f000 f908 	bl	277c <_lseek_r>
    256c:	89a3      	ldrh	r3, [r4, #12]
    256e:	1c42      	adds	r2, r0, #1
    2570:	d103      	bne.n	257a <__sseek+0x1a>
    2572:	4a05      	ldr	r2, [pc, #20]	; (2588 <__sseek+0x28>)
    2574:	4013      	ands	r3, r2
    2576:	81a3      	strh	r3, [r4, #12]
    2578:	e004      	b.n	2584 <__sseek+0x24>
    257a:	2280      	movs	r2, #128	; 0x80
    257c:	0152      	lsls	r2, r2, #5
    257e:	4313      	orrs	r3, r2
    2580:	81a3      	strh	r3, [r4, #12]
    2582:	6560      	str	r0, [r4, #84]	; 0x54
    2584:	bd38      	pop	{r3, r4, r5, pc}
    2586:	46c0      	nop			; (mov r8, r8)
    2588:	ffffefff 	.word	0xffffefff

0000258c <__sclose>:
    258c:	b508      	push	{r3, lr}
    258e:	230e      	movs	r3, #14
    2590:	5ec9      	ldrsh	r1, [r1, r3]
    2592:	f000 f8e1 	bl	2758 <_close_r>
    2596:	bd08      	pop	{r3, pc}

00002598 <__swbuf_r>:
    2598:	b570      	push	{r4, r5, r6, lr}
    259a:	1c05      	adds	r5, r0, #0
    259c:	1c0e      	adds	r6, r1, #0
    259e:	1c14      	adds	r4, r2, #0
    25a0:	2800      	cmp	r0, #0
    25a2:	d004      	beq.n	25ae <__swbuf_r+0x16>
    25a4:	6983      	ldr	r3, [r0, #24]
    25a6:	2b00      	cmp	r3, #0
    25a8:	d101      	bne.n	25ae <__swbuf_r+0x16>
    25aa:	f7ff fb63 	bl	1c74 <__sinit>
    25ae:	4b23      	ldr	r3, [pc, #140]	; (263c <__swbuf_r+0xa4>)
    25b0:	429c      	cmp	r4, r3
    25b2:	d101      	bne.n	25b8 <__swbuf_r+0x20>
    25b4:	686c      	ldr	r4, [r5, #4]
    25b6:	e008      	b.n	25ca <__swbuf_r+0x32>
    25b8:	4b21      	ldr	r3, [pc, #132]	; (2640 <__swbuf_r+0xa8>)
    25ba:	429c      	cmp	r4, r3
    25bc:	d101      	bne.n	25c2 <__swbuf_r+0x2a>
    25be:	68ac      	ldr	r4, [r5, #8]
    25c0:	e003      	b.n	25ca <__swbuf_r+0x32>
    25c2:	4b20      	ldr	r3, [pc, #128]	; (2644 <__swbuf_r+0xac>)
    25c4:	429c      	cmp	r4, r3
    25c6:	d100      	bne.n	25ca <__swbuf_r+0x32>
    25c8:	68ec      	ldr	r4, [r5, #12]
    25ca:	69a3      	ldr	r3, [r4, #24]
    25cc:	60a3      	str	r3, [r4, #8]
    25ce:	89a3      	ldrh	r3, [r4, #12]
    25d0:	071b      	lsls	r3, r3, #28
    25d2:	d50a      	bpl.n	25ea <__swbuf_r+0x52>
    25d4:	6923      	ldr	r3, [r4, #16]
    25d6:	2b00      	cmp	r3, #0
    25d8:	d007      	beq.n	25ea <__swbuf_r+0x52>
    25da:	6823      	ldr	r3, [r4, #0]
    25dc:	6922      	ldr	r2, [r4, #16]
    25de:	b2f6      	uxtb	r6, r6
    25e0:	1a98      	subs	r0, r3, r2
    25e2:	6963      	ldr	r3, [r4, #20]
    25e4:	4298      	cmp	r0, r3
    25e6:	db0f      	blt.n	2608 <__swbuf_r+0x70>
    25e8:	e008      	b.n	25fc <__swbuf_r+0x64>
    25ea:	1c28      	adds	r0, r5, #0
    25ec:	1c21      	adds	r1, r4, #0
    25ee:	f000 f83f 	bl	2670 <__swsetup_r>
    25f2:	2800      	cmp	r0, #0
    25f4:	d0f1      	beq.n	25da <__swbuf_r+0x42>
    25f6:	2001      	movs	r0, #1
    25f8:	4240      	negs	r0, r0
    25fa:	e01d      	b.n	2638 <__swbuf_r+0xa0>
    25fc:	1c28      	adds	r0, r5, #0
    25fe:	1c21      	adds	r1, r4, #0
    2600:	f7ff faca 	bl	1b98 <_fflush_r>
    2604:	2800      	cmp	r0, #0
    2606:	d1f6      	bne.n	25f6 <__swbuf_r+0x5e>
    2608:	68a3      	ldr	r3, [r4, #8]
    260a:	3001      	adds	r0, #1
    260c:	3b01      	subs	r3, #1
    260e:	60a3      	str	r3, [r4, #8]
    2610:	6823      	ldr	r3, [r4, #0]
    2612:	1c5a      	adds	r2, r3, #1
    2614:	6022      	str	r2, [r4, #0]
    2616:	701e      	strb	r6, [r3, #0]
    2618:	6963      	ldr	r3, [r4, #20]
    261a:	4298      	cmp	r0, r3
    261c:	d005      	beq.n	262a <__swbuf_r+0x92>
    261e:	89a3      	ldrh	r3, [r4, #12]
    2620:	1c30      	adds	r0, r6, #0
    2622:	07db      	lsls	r3, r3, #31
    2624:	d508      	bpl.n	2638 <__swbuf_r+0xa0>
    2626:	2e0a      	cmp	r6, #10
    2628:	d106      	bne.n	2638 <__swbuf_r+0xa0>
    262a:	1c28      	adds	r0, r5, #0
    262c:	1c21      	adds	r1, r4, #0
    262e:	f7ff fab3 	bl	1b98 <_fflush_r>
    2632:	2800      	cmp	r0, #0
    2634:	d1df      	bne.n	25f6 <__swbuf_r+0x5e>
    2636:	1c30      	adds	r0, r6, #0
    2638:	bd70      	pop	{r4, r5, r6, pc}
    263a:	46c0      	nop			; (mov r8, r8)
    263c:	00002964 	.word	0x00002964
    2640:	00002984 	.word	0x00002984
    2644:	000029a4 	.word	0x000029a4

00002648 <_write_r>:
    2648:	b538      	push	{r3, r4, r5, lr}
    264a:	1c05      	adds	r5, r0, #0
    264c:	2000      	movs	r0, #0
    264e:	4c07      	ldr	r4, [pc, #28]	; (266c <_write_r+0x24>)
    2650:	6020      	str	r0, [r4, #0]
    2652:	1c08      	adds	r0, r1, #0
    2654:	1c11      	adds	r1, r2, #0
    2656:	1c1a      	adds	r2, r3, #0
    2658:	f7fd ff7c 	bl	554 <_write>
    265c:	1c43      	adds	r3, r0, #1
    265e:	d103      	bne.n	2668 <_write_r+0x20>
    2660:	6823      	ldr	r3, [r4, #0]
    2662:	2b00      	cmp	r3, #0
    2664:	d000      	beq.n	2668 <_write_r+0x20>
    2666:	602b      	str	r3, [r5, #0]
    2668:	bd38      	pop	{r3, r4, r5, pc}
    266a:	46c0      	nop			; (mov r8, r8)
    266c:	20000124 	.word	0x20000124

00002670 <__swsetup_r>:
    2670:	4b35      	ldr	r3, [pc, #212]	; (2748 <__swsetup_r+0xd8>)
    2672:	b570      	push	{r4, r5, r6, lr}
    2674:	681d      	ldr	r5, [r3, #0]
    2676:	1c06      	adds	r6, r0, #0
    2678:	1c0c      	adds	r4, r1, #0
    267a:	2d00      	cmp	r5, #0
    267c:	d005      	beq.n	268a <__swsetup_r+0x1a>
    267e:	69ab      	ldr	r3, [r5, #24]
    2680:	2b00      	cmp	r3, #0
    2682:	d102      	bne.n	268a <__swsetup_r+0x1a>
    2684:	1c28      	adds	r0, r5, #0
    2686:	f7ff faf5 	bl	1c74 <__sinit>
    268a:	4b30      	ldr	r3, [pc, #192]	; (274c <__swsetup_r+0xdc>)
    268c:	429c      	cmp	r4, r3
    268e:	d101      	bne.n	2694 <__swsetup_r+0x24>
    2690:	686c      	ldr	r4, [r5, #4]
    2692:	e008      	b.n	26a6 <__swsetup_r+0x36>
    2694:	4b2e      	ldr	r3, [pc, #184]	; (2750 <__swsetup_r+0xe0>)
    2696:	429c      	cmp	r4, r3
    2698:	d101      	bne.n	269e <__swsetup_r+0x2e>
    269a:	68ac      	ldr	r4, [r5, #8]
    269c:	e003      	b.n	26a6 <__swsetup_r+0x36>
    269e:	4b2d      	ldr	r3, [pc, #180]	; (2754 <__swsetup_r+0xe4>)
    26a0:	429c      	cmp	r4, r3
    26a2:	d100      	bne.n	26a6 <__swsetup_r+0x36>
    26a4:	68ec      	ldr	r4, [r5, #12]
    26a6:	89a3      	ldrh	r3, [r4, #12]
    26a8:	b29a      	uxth	r2, r3
    26aa:	0711      	lsls	r1, r2, #28
    26ac:	d423      	bmi.n	26f6 <__swsetup_r+0x86>
    26ae:	06d1      	lsls	r1, r2, #27
    26b0:	d407      	bmi.n	26c2 <__swsetup_r+0x52>
    26b2:	2209      	movs	r2, #9
    26b4:	2001      	movs	r0, #1
    26b6:	6032      	str	r2, [r6, #0]
    26b8:	3237      	adds	r2, #55	; 0x37
    26ba:	4313      	orrs	r3, r2
    26bc:	81a3      	strh	r3, [r4, #12]
    26be:	4240      	negs	r0, r0
    26c0:	e040      	b.n	2744 <__swsetup_r+0xd4>
    26c2:	0753      	lsls	r3, r2, #29
    26c4:	d513      	bpl.n	26ee <__swsetup_r+0x7e>
    26c6:	6b61      	ldr	r1, [r4, #52]	; 0x34
    26c8:	2900      	cmp	r1, #0
    26ca:	d008      	beq.n	26de <__swsetup_r+0x6e>
    26cc:	1c23      	adds	r3, r4, #0
    26ce:	3344      	adds	r3, #68	; 0x44
    26d0:	4299      	cmp	r1, r3
    26d2:	d002      	beq.n	26da <__swsetup_r+0x6a>
    26d4:	1c30      	adds	r0, r6, #0
    26d6:	f7ff fb69 	bl	1dac <_free_r>
    26da:	2300      	movs	r3, #0
    26dc:	6363      	str	r3, [r4, #52]	; 0x34
    26de:	2224      	movs	r2, #36	; 0x24
    26e0:	89a3      	ldrh	r3, [r4, #12]
    26e2:	4393      	bics	r3, r2
    26e4:	81a3      	strh	r3, [r4, #12]
    26e6:	2300      	movs	r3, #0
    26e8:	6063      	str	r3, [r4, #4]
    26ea:	6923      	ldr	r3, [r4, #16]
    26ec:	6023      	str	r3, [r4, #0]
    26ee:	2208      	movs	r2, #8
    26f0:	89a3      	ldrh	r3, [r4, #12]
    26f2:	4313      	orrs	r3, r2
    26f4:	81a3      	strh	r3, [r4, #12]
    26f6:	6923      	ldr	r3, [r4, #16]
    26f8:	2b00      	cmp	r3, #0
    26fa:	d10b      	bne.n	2714 <__swsetup_r+0xa4>
    26fc:	23a0      	movs	r3, #160	; 0xa0
    26fe:	89a2      	ldrh	r2, [r4, #12]
    2700:	009b      	lsls	r3, r3, #2
    2702:	4013      	ands	r3, r2
    2704:	2280      	movs	r2, #128	; 0x80
    2706:	0092      	lsls	r2, r2, #2
    2708:	4293      	cmp	r3, r2
    270a:	d003      	beq.n	2714 <__swsetup_r+0xa4>
    270c:	1c30      	adds	r0, r6, #0
    270e:	1c21      	adds	r1, r4, #0
    2710:	f000 f848 	bl	27a4 <__smakebuf_r>
    2714:	2301      	movs	r3, #1
    2716:	89a2      	ldrh	r2, [r4, #12]
    2718:	4013      	ands	r3, r2
    271a:	d005      	beq.n	2728 <__swsetup_r+0xb8>
    271c:	2300      	movs	r3, #0
    271e:	60a3      	str	r3, [r4, #8]
    2720:	6963      	ldr	r3, [r4, #20]
    2722:	425b      	negs	r3, r3
    2724:	61a3      	str	r3, [r4, #24]
    2726:	e003      	b.n	2730 <__swsetup_r+0xc0>
    2728:	0791      	lsls	r1, r2, #30
    272a:	d400      	bmi.n	272e <__swsetup_r+0xbe>
    272c:	6963      	ldr	r3, [r4, #20]
    272e:	60a3      	str	r3, [r4, #8]
    2730:	2000      	movs	r0, #0
    2732:	6923      	ldr	r3, [r4, #16]
    2734:	4283      	cmp	r3, r0
    2736:	d105      	bne.n	2744 <__swsetup_r+0xd4>
    2738:	0613      	lsls	r3, r2, #24
    273a:	d503      	bpl.n	2744 <__swsetup_r+0xd4>
    273c:	2340      	movs	r3, #64	; 0x40
    273e:	431a      	orrs	r2, r3
    2740:	81a2      	strh	r2, [r4, #12]
    2742:	3801      	subs	r0, #1
    2744:	bd70      	pop	{r4, r5, r6, pc}
    2746:	46c0      	nop			; (mov r8, r8)
    2748:	20000064 	.word	0x20000064
    274c:	00002964 	.word	0x00002964
    2750:	00002984 	.word	0x00002984
    2754:	000029a4 	.word	0x000029a4

00002758 <_close_r>:
    2758:	b538      	push	{r3, r4, r5, lr}
    275a:	2300      	movs	r3, #0
    275c:	4c06      	ldr	r4, [pc, #24]	; (2778 <_close_r+0x20>)
    275e:	1c05      	adds	r5, r0, #0
    2760:	1c08      	adds	r0, r1, #0
    2762:	6023      	str	r3, [r4, #0]
    2764:	f7fe fee2 	bl	152c <_close>
    2768:	1c43      	adds	r3, r0, #1
    276a:	d103      	bne.n	2774 <_close_r+0x1c>
    276c:	6823      	ldr	r3, [r4, #0]
    276e:	2b00      	cmp	r3, #0
    2770:	d000      	beq.n	2774 <_close_r+0x1c>
    2772:	602b      	str	r3, [r5, #0]
    2774:	bd38      	pop	{r3, r4, r5, pc}
    2776:	46c0      	nop			; (mov r8, r8)
    2778:	20000124 	.word	0x20000124

0000277c <_lseek_r>:
    277c:	b538      	push	{r3, r4, r5, lr}
    277e:	1c05      	adds	r5, r0, #0
    2780:	2000      	movs	r0, #0
    2782:	4c07      	ldr	r4, [pc, #28]	; (27a0 <_lseek_r+0x24>)
    2784:	6020      	str	r0, [r4, #0]
    2786:	1c08      	adds	r0, r1, #0
    2788:	1c11      	adds	r1, r2, #0
    278a:	1c1a      	adds	r2, r3, #0
    278c:	f7fe feda 	bl	1544 <_lseek>
    2790:	1c43      	adds	r3, r0, #1
    2792:	d103      	bne.n	279c <_lseek_r+0x20>
    2794:	6823      	ldr	r3, [r4, #0]
    2796:	2b00      	cmp	r3, #0
    2798:	d000      	beq.n	279c <_lseek_r+0x20>
    279a:	602b      	str	r3, [r5, #0]
    279c:	bd38      	pop	{r3, r4, r5, pc}
    279e:	46c0      	nop			; (mov r8, r8)
    27a0:	20000124 	.word	0x20000124

000027a4 <__smakebuf_r>:
    27a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    27a6:	898b      	ldrh	r3, [r1, #12]
    27a8:	b091      	sub	sp, #68	; 0x44
    27aa:	079b      	lsls	r3, r3, #30
    27ac:	d506      	bpl.n	27bc <__smakebuf_r+0x18>
    27ae:	1c0b      	adds	r3, r1, #0
    27b0:	3347      	adds	r3, #71	; 0x47
    27b2:	600b      	str	r3, [r1, #0]
    27b4:	610b      	str	r3, [r1, #16]
    27b6:	2301      	movs	r3, #1
    27b8:	614b      	str	r3, [r1, #20]
    27ba:	e045      	b.n	2848 <__smakebuf_r+0xa4>
    27bc:	1c0c      	adds	r4, r1, #0
    27be:	230e      	movs	r3, #14
    27c0:	5ec9      	ldrsh	r1, [r1, r3]
    27c2:	1c06      	adds	r6, r0, #0
    27c4:	2900      	cmp	r1, #0
    27c6:	da04      	bge.n	27d2 <__smakebuf_r+0x2e>
    27c8:	2380      	movs	r3, #128	; 0x80
    27ca:	89a5      	ldrh	r5, [r4, #12]
    27cc:	401d      	ands	r5, r3
    27ce:	d110      	bne.n	27f2 <__smakebuf_r+0x4e>
    27d0:	e00c      	b.n	27ec <__smakebuf_r+0x48>
    27d2:	aa01      	add	r2, sp, #4
    27d4:	f000 f85e 	bl	2894 <_fstat_r>
    27d8:	2800      	cmp	r0, #0
    27da:	dbf5      	blt.n	27c8 <__smakebuf_r+0x24>
    27dc:	23f0      	movs	r3, #240	; 0xf0
    27de:	9d02      	ldr	r5, [sp, #8]
    27e0:	021b      	lsls	r3, r3, #8
    27e2:	401d      	ands	r5, r3
    27e4:	4b19      	ldr	r3, [pc, #100]	; (284c <__smakebuf_r+0xa8>)
    27e6:	18ed      	adds	r5, r5, r3
    27e8:	426b      	negs	r3, r5
    27ea:	415d      	adcs	r5, r3
    27ec:	2780      	movs	r7, #128	; 0x80
    27ee:	00ff      	lsls	r7, r7, #3
    27f0:	e001      	b.n	27f6 <__smakebuf_r+0x52>
    27f2:	2500      	movs	r5, #0
    27f4:	2740      	movs	r7, #64	; 0x40
    27f6:	1c30      	adds	r0, r6, #0
    27f8:	1c39      	adds	r1, r7, #0
    27fa:	f7ff fb1d 	bl	1e38 <_malloc_r>
    27fe:	2800      	cmp	r0, #0
    2800:	d10c      	bne.n	281c <__smakebuf_r+0x78>
    2802:	89a3      	ldrh	r3, [r4, #12]
    2804:	059a      	lsls	r2, r3, #22
    2806:	d41f      	bmi.n	2848 <__smakebuf_r+0xa4>
    2808:	2202      	movs	r2, #2
    280a:	4313      	orrs	r3, r2
    280c:	81a3      	strh	r3, [r4, #12]
    280e:	1c23      	adds	r3, r4, #0
    2810:	3347      	adds	r3, #71	; 0x47
    2812:	6023      	str	r3, [r4, #0]
    2814:	6123      	str	r3, [r4, #16]
    2816:	2301      	movs	r3, #1
    2818:	6163      	str	r3, [r4, #20]
    281a:	e015      	b.n	2848 <__smakebuf_r+0xa4>
    281c:	2280      	movs	r2, #128	; 0x80
    281e:	4b0c      	ldr	r3, [pc, #48]	; (2850 <__smakebuf_r+0xac>)
    2820:	62b3      	str	r3, [r6, #40]	; 0x28
    2822:	89a3      	ldrh	r3, [r4, #12]
    2824:	6020      	str	r0, [r4, #0]
    2826:	4313      	orrs	r3, r2
    2828:	81a3      	strh	r3, [r4, #12]
    282a:	6120      	str	r0, [r4, #16]
    282c:	6167      	str	r7, [r4, #20]
    282e:	2d00      	cmp	r5, #0
    2830:	d00a      	beq.n	2848 <__smakebuf_r+0xa4>
    2832:	230e      	movs	r3, #14
    2834:	5ee1      	ldrsh	r1, [r4, r3]
    2836:	1c30      	adds	r0, r6, #0
    2838:	f000 f83e 	bl	28b8 <_isatty_r>
    283c:	2800      	cmp	r0, #0
    283e:	d003      	beq.n	2848 <__smakebuf_r+0xa4>
    2840:	2201      	movs	r2, #1
    2842:	89a3      	ldrh	r3, [r4, #12]
    2844:	4313      	orrs	r3, r2
    2846:	81a3      	strh	r3, [r4, #12]
    2848:	b011      	add	sp, #68	; 0x44
    284a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    284c:	ffffe000 	.word	0xffffe000
    2850:	00001bf1 	.word	0x00001bf1

00002854 <memchr>:
    2854:	b2c9      	uxtb	r1, r1
    2856:	1882      	adds	r2, r0, r2
    2858:	4290      	cmp	r0, r2
    285a:	d004      	beq.n	2866 <memchr+0x12>
    285c:	7803      	ldrb	r3, [r0, #0]
    285e:	428b      	cmp	r3, r1
    2860:	d002      	beq.n	2868 <memchr+0x14>
    2862:	3001      	adds	r0, #1
    2864:	e7f8      	b.n	2858 <memchr+0x4>
    2866:	2000      	movs	r0, #0
    2868:	4770      	bx	lr
	...

0000286c <_read_r>:
    286c:	b538      	push	{r3, r4, r5, lr}
    286e:	1c05      	adds	r5, r0, #0
    2870:	2000      	movs	r0, #0
    2872:	4c07      	ldr	r4, [pc, #28]	; (2890 <_read_r+0x24>)
    2874:	6020      	str	r0, [r4, #0]
    2876:	1c08      	adds	r0, r1, #0
    2878:	1c11      	adds	r1, r2, #0
    287a:	1c1a      	adds	r2, r3, #0
    287c:	f7fd fe48 	bl	510 <_read>
    2880:	1c43      	adds	r3, r0, #1
    2882:	d103      	bne.n	288c <_read_r+0x20>
    2884:	6823      	ldr	r3, [r4, #0]
    2886:	2b00      	cmp	r3, #0
    2888:	d000      	beq.n	288c <_read_r+0x20>
    288a:	602b      	str	r3, [r5, #0]
    288c:	bd38      	pop	{r3, r4, r5, pc}
    288e:	46c0      	nop			; (mov r8, r8)
    2890:	20000124 	.word	0x20000124

00002894 <_fstat_r>:
    2894:	b538      	push	{r3, r4, r5, lr}
    2896:	2300      	movs	r3, #0
    2898:	4c06      	ldr	r4, [pc, #24]	; (28b4 <_fstat_r+0x20>)
    289a:	1c05      	adds	r5, r0, #0
    289c:	1c08      	adds	r0, r1, #0
    289e:	1c11      	adds	r1, r2, #0
    28a0:	6023      	str	r3, [r4, #0]
    28a2:	f7fe fe47 	bl	1534 <_fstat>
    28a6:	1c43      	adds	r3, r0, #1
    28a8:	d103      	bne.n	28b2 <_fstat_r+0x1e>
    28aa:	6823      	ldr	r3, [r4, #0]
    28ac:	2b00      	cmp	r3, #0
    28ae:	d000      	beq.n	28b2 <_fstat_r+0x1e>
    28b0:	602b      	str	r3, [r5, #0]
    28b2:	bd38      	pop	{r3, r4, r5, pc}
    28b4:	20000124 	.word	0x20000124

000028b8 <_isatty_r>:
    28b8:	b538      	push	{r3, r4, r5, lr}
    28ba:	2300      	movs	r3, #0
    28bc:	4c06      	ldr	r4, [pc, #24]	; (28d8 <_isatty_r+0x20>)
    28be:	1c05      	adds	r5, r0, #0
    28c0:	1c08      	adds	r0, r1, #0
    28c2:	6023      	str	r3, [r4, #0]
    28c4:	f7fe fe3c 	bl	1540 <_isatty>
    28c8:	1c43      	adds	r3, r0, #1
    28ca:	d103      	bne.n	28d4 <_isatty_r+0x1c>
    28cc:	6823      	ldr	r3, [r4, #0]
    28ce:	2b00      	cmp	r3, #0
    28d0:	d000      	beq.n	28d4 <_isatty_r+0x1c>
    28d2:	602b      	str	r3, [r5, #0]
    28d4:	bd38      	pop	{r3, r4, r5, pc}
    28d6:	46c0      	nop			; (mov r8, r8)
    28d8:	20000124 	.word	0x20000124
    28dc:	42000800 	.word	0x42000800
    28e0:	42000c00 	.word	0x42000c00
    28e4:	42001000 	.word	0x42001000
    28e8:	42001400 	.word	0x42001400
    28ec:	42001800 	.word	0x42001800
    28f0:	42001c00 	.word	0x42001c00
    28f4:	0c0b0a09 	.word	0x0c0b0a09
    28f8:	00000e0d 	.word	0x00000e0d
    28fc:	00000e5e 	.word	0x00000e5e
    2900:	00000e5a 	.word	0x00000e5a
    2904:	00000e5a 	.word	0x00000e5a
    2908:	00000eba 	.word	0x00000eba
    290c:	00000eba 	.word	0x00000eba
    2910:	00000e74 	.word	0x00000e74
    2914:	00000e64 	.word	0x00000e64
    2918:	00000e7a 	.word	0x00000e7a
    291c:	00000ea8 	.word	0x00000ea8
    2920:	00000f44 	.word	0x00000f44
    2924:	00000f24 	.word	0x00000f24
    2928:	00000f24 	.word	0x00000f24
    292c:	00000fb0 	.word	0x00000fb0
    2930:	00000f36 	.word	0x00000f36
    2934:	00000f52 	.word	0x00000f52
    2938:	00000f28 	.word	0x00000f28
    293c:	00000f60 	.word	0x00000f60
    2940:	00000fa0 	.word	0x00000fa0
    2944:	61207055 	.word	0x61207055
    2948:	7220646e 	.word	0x7220646e
    294c:	696e6e75 	.word	0x696e6e75
    2950:	0d21676e 	.word	0x0d21676e
    2954:	00000000 	.word	0x00000000
    2958:	00006425 	.word	0x00006425
    295c:	00000043 	.word	0x00000043

00002960 <_global_impure_ptr>:
    2960:	20000004                                ... 

00002964 <__sf_fake_stdin>:
	...

00002984 <__sf_fake_stdout>:
	...

000029a4 <__sf_fake_stderr>:
	...
    29c4:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    29d4:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    29e4:	31300046 35343332 39383736 64636261     F.0123456789abcd
    29f4:	00006665                                ef..

000029f8 <_init>:
    29f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    29fa:	46c0      	nop			; (mov r8, r8)
    29fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    29fe:	bc08      	pop	{r3}
    2a00:	469e      	mov	lr, r3
    2a02:	4770      	bx	lr

00002a04 <__init_array_start>:
    2a04:	000000d9 	.word	0x000000d9

00002a08 <_fini>:
    2a08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a0a:	46c0      	nop			; (mov r8, r8)
    2a0c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2a0e:	bc08      	pop	{r3}
    2a10:	469e      	mov	lr, r3
    2a12:	4770      	bx	lr

00002a14 <__fini_array_start>:
    2a14:	000000b1 	.word	0x000000b1
